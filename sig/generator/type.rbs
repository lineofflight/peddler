module Generator
  class Type
    include Formatter

    @type_resolver: TypeResolver?

    attr_reader api_name: String

    attr_accessor circular_dependencies: Set[String]?
    attr_accessor cycle_edges: Set[[ String, String ]]?
    attr_reader definition: Hash[String, untyped]
    attr_reader name: String

    attr_reader specification: Hash[String, untyped]?

    def initialize: (String name, Hash[String, untyped] definition, String api_name, ?Hash[String, untyped]? specification) -> void

    def attribute_name_for: (String prop_name, Hash[String, untyped] prop_def) -> String
    def class_name: () -> String
    def generate: () -> void

    def generate_rbs: () -> void
    def library_name: () -> String

    def needs_money?: () -> bool
    def properties: () -> Hash[String, untyped]

    def required_properties: () -> (Array[String] | untyped)

    def ruby_type_for: (Hash[String, untyped] prop_def, ?for_comment: bool, ?for_rbs: bool) -> String

    def type_dependencies: () -> Array[String]

    def uses_string_class_names?: () -> bool

    private

    def array_item_type: () -> String?

    def array_template: () -> String
    def array_type?: () -> bool
    def class_description: () -> String?
    def extract_dependencies_from_property: (Hash[String, untyped] prop_def) -> Array[String]

    def file_path: () -> String

    def format_property_comment: (Hash[String, untyped] prop_def) -> String

    def generate_array_rbs: () -> String
    def generate_structure_rbs: () -> String
    def generated_type?: (String type_name) -> bool
    def merge_from_all_of: [T] (String field_name) { (untyped) -> T } -> (Hash[String, untyped] | Array[String] | untyped)

    def render: () -> String
    def sorted_properties: (Hash[String, untyped] props) -> Hash[String, untyped]

    def template: () -> String
    def type_resolver: () -> TypeResolver

    def wrap_rbs_in_modules: (String rbs_content) -> String
  end
end

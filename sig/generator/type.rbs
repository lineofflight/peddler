# frozen_string_literal: true

module Generator
  class Type
    include Formatter

    @type_resolver: TypeResolver?

    attr_reader name: String
    attr_reader definition: Hash[String, untyped]
    attr_reader api_name: String
    attr_reader specification: Hash[String, untyped]?

    attr_accessor circular_dependencies: Set[String]?
    attr_accessor cycle_edges: Set[[String, String]]?

    def initialize: (
      String name,
      Hash[String, untyped] definition,
      String api_name,
      ?Hash[String, untyped]? specification
    ) -> void

    def generate: () -> void

    def class_name: () -> String

    def properties: () -> Hash[String, untyped]

    def required_properties: () -> (Array[String] | untyped)

    def library_name: () -> String

    def ruby_type_for: (Hash[String, untyped] prop_def, ?for_comment: bool, ?for_rbs: bool) -> String

    def type_dependencies: () -> Array[String]

    def needs_money?: () -> bool

    def uses_string_class_names?: () -> bool

    def attribute_name_for: (String prop_name, Hash[String, untyped] prop_def) -> String

    def generate_rbs: () -> void

    private

    def sorted_properties: (Hash[String, untyped] props) -> Hash[String, untyped]

    def merge_from_all_of: [T] (String field_name) { (untyped) -> T } -> (Hash[String, untyped] | Array[String] | untyped)

    def extract_dependencies_from_property: (Hash[String, untyped] prop_def) -> Array[String]

    def generated_type?: (String type_name) -> bool

    def type_resolver: () -> TypeResolver

    def file_path: () -> String

    def format_property_comment: (Hash[String, untyped] prop_def) -> String

    def class_description: () -> String?

    def render: () -> String

    def template: () -> String

    def array_type?: () -> bool

    def array_item_type: () -> String?

    def array_template: () -> String

    def generate_structure_rbs: () -> String

    def generate_array_rbs: () -> String

    def wrap_rbs_in_modules: (String rbs_content) -> String
  end
end

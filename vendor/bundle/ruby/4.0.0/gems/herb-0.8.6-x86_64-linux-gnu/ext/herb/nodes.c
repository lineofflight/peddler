// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/ext/herb/nodes.c.erb

#include <ruby.h>

#include "error_helpers.h"
#include "extension_helpers.h"
#include "extension.h"
#include "nodes.h"

#include "../../src/include/herb.h"
#include "../../src/include/token.h"

VALUE rb_node_from_c_struct(AST_NODE_T* node);
static VALUE rb_nodes_array_from_c_array(hb_array_T* array);

static VALUE rb_document_node_from_c_struct(AST_DOCUMENT_NODE_T* document_node) {
  if (document_node == NULL) { return Qnil; }

  AST_NODE_T* node = &document_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE DocumentNode = rb_define_class_under(AST, "DocumentNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE document_node_children = rb_nodes_array_from_c_array(document_node->children);

  VALUE args[4] = {
    type,
    location,
    errors,
    document_node_children
  };

  return rb_class_new_instance(4, args, DocumentNode);
};

static VALUE rb_literal_node_from_c_struct(AST_LITERAL_NODE_T* literal_node) {
  if (literal_node == NULL) { return Qnil; }

  AST_NODE_T* node = &literal_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE LiteralNode = rb_define_class_under(AST, "LiteralNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE literal_node_content = rb_utf8_str_new_cstr(literal_node->content);

  VALUE args[4] = {
    type,
    location,
    errors,
    literal_node_content
  };

  return rb_class_new_instance(4, args, LiteralNode);
};

static VALUE rb_html_open_tag_node_from_c_struct(AST_HTML_OPEN_TAG_NODE_T* html_open_tag_node) {
  if (html_open_tag_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_open_tag_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLOpenTagNode = rb_define_class_under(AST, "HTMLOpenTagNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_open_tag_node_tag_opening = rb_token_from_c_struct(html_open_tag_node->tag_opening);
  VALUE html_open_tag_node_tag_name = rb_token_from_c_struct(html_open_tag_node->tag_name);
  VALUE html_open_tag_node_tag_closing = rb_token_from_c_struct(html_open_tag_node->tag_closing);
  VALUE html_open_tag_node_children = rb_nodes_array_from_c_array(html_open_tag_node->children);
  VALUE html_open_tag_node_is_void = (html_open_tag_node->is_void) ? Qtrue : Qfalse;

  VALUE args[8] = {
    type,
    location,
    errors,
    html_open_tag_node_tag_opening,
    html_open_tag_node_tag_name,
    html_open_tag_node_tag_closing,
    html_open_tag_node_children,
    html_open_tag_node_is_void
  };

  return rb_class_new_instance(8, args, HTMLOpenTagNode);
};

static VALUE rb_html_close_tag_node_from_c_struct(AST_HTML_CLOSE_TAG_NODE_T* html_close_tag_node) {
  if (html_close_tag_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_close_tag_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLCloseTagNode = rb_define_class_under(AST, "HTMLCloseTagNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_close_tag_node_tag_opening = rb_token_from_c_struct(html_close_tag_node->tag_opening);
  VALUE html_close_tag_node_tag_name = rb_token_from_c_struct(html_close_tag_node->tag_name);
  VALUE html_close_tag_node_children = rb_nodes_array_from_c_array(html_close_tag_node->children);
  VALUE html_close_tag_node_tag_closing = rb_token_from_c_struct(html_close_tag_node->tag_closing);

  VALUE args[7] = {
    type,
    location,
    errors,
    html_close_tag_node_tag_opening,
    html_close_tag_node_tag_name,
    html_close_tag_node_children,
    html_close_tag_node_tag_closing
  };

  return rb_class_new_instance(7, args, HTMLCloseTagNode);
};

static VALUE rb_html_element_node_from_c_struct(AST_HTML_ELEMENT_NODE_T* html_element_node) {
  if (html_element_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_element_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLElementNode = rb_define_class_under(AST, "HTMLElementNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_element_node_open_tag = rb_node_from_c_struct((AST_NODE_T*) html_element_node->open_tag);
  VALUE html_element_node_tag_name = rb_token_from_c_struct(html_element_node->tag_name);
  VALUE html_element_node_body = rb_nodes_array_from_c_array(html_element_node->body);
  VALUE html_element_node_close_tag = rb_node_from_c_struct((AST_NODE_T*) html_element_node->close_tag);
  VALUE html_element_node_is_void = (html_element_node->is_void) ? Qtrue : Qfalse;
  VALUE html_element_node_source;
  {
    hb_string_T element_source_string = element_source_to_string(html_element_node->source);
    html_element_node_source = rb_utf8_str_new(element_source_string.data, element_source_string.length);
  }

  VALUE args[9] = {
    type,
    location,
    errors,
    html_element_node_open_tag,
    html_element_node_tag_name,
    html_element_node_body,
    html_element_node_close_tag,
    html_element_node_is_void,
    html_element_node_source
  };

  return rb_class_new_instance(9, args, HTMLElementNode);
};

static VALUE rb_html_attribute_value_node_from_c_struct(AST_HTML_ATTRIBUTE_VALUE_NODE_T* html_attribute_value_node) {
  if (html_attribute_value_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_attribute_value_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLAttributeValueNode = rb_define_class_under(AST, "HTMLAttributeValueNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_attribute_value_node_open_quote = rb_token_from_c_struct(html_attribute_value_node->open_quote);
  VALUE html_attribute_value_node_children = rb_nodes_array_from_c_array(html_attribute_value_node->children);
  VALUE html_attribute_value_node_close_quote = rb_token_from_c_struct(html_attribute_value_node->close_quote);
  VALUE html_attribute_value_node_quoted = (html_attribute_value_node->quoted) ? Qtrue : Qfalse;

  VALUE args[7] = {
    type,
    location,
    errors,
    html_attribute_value_node_open_quote,
    html_attribute_value_node_children,
    html_attribute_value_node_close_quote,
    html_attribute_value_node_quoted
  };

  return rb_class_new_instance(7, args, HTMLAttributeValueNode);
};

static VALUE rb_html_attribute_name_node_from_c_struct(AST_HTML_ATTRIBUTE_NAME_NODE_T* html_attribute_name_node) {
  if (html_attribute_name_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_attribute_name_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLAttributeNameNode = rb_define_class_under(AST, "HTMLAttributeNameNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_attribute_name_node_children = rb_nodes_array_from_c_array(html_attribute_name_node->children);

  VALUE args[4] = {
    type,
    location,
    errors,
    html_attribute_name_node_children
  };

  return rb_class_new_instance(4, args, HTMLAttributeNameNode);
};

static VALUE rb_html_attribute_node_from_c_struct(AST_HTML_ATTRIBUTE_NODE_T* html_attribute_node) {
  if (html_attribute_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_attribute_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLAttributeNode = rb_define_class_under(AST, "HTMLAttributeNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_attribute_node_name = rb_node_from_c_struct((AST_NODE_T*) html_attribute_node->name);
  VALUE html_attribute_node_equals = rb_token_from_c_struct(html_attribute_node->equals);
  VALUE html_attribute_node_value = rb_node_from_c_struct((AST_NODE_T*) html_attribute_node->value);

  VALUE args[6] = {
    type,
    location,
    errors,
    html_attribute_node_name,
    html_attribute_node_equals,
    html_attribute_node_value
  };

  return rb_class_new_instance(6, args, HTMLAttributeNode);
};

static VALUE rb_html_text_node_from_c_struct(AST_HTML_TEXT_NODE_T* html_text_node) {
  if (html_text_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_text_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLTextNode = rb_define_class_under(AST, "HTMLTextNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_text_node_content = rb_utf8_str_new_cstr(html_text_node->content);

  VALUE args[4] = {
    type,
    location,
    errors,
    html_text_node_content
  };

  return rb_class_new_instance(4, args, HTMLTextNode);
};

static VALUE rb_html_comment_node_from_c_struct(AST_HTML_COMMENT_NODE_T* html_comment_node) {
  if (html_comment_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_comment_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLCommentNode = rb_define_class_under(AST, "HTMLCommentNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_comment_node_comment_start = rb_token_from_c_struct(html_comment_node->comment_start);
  VALUE html_comment_node_children = rb_nodes_array_from_c_array(html_comment_node->children);
  VALUE html_comment_node_comment_end = rb_token_from_c_struct(html_comment_node->comment_end);

  VALUE args[6] = {
    type,
    location,
    errors,
    html_comment_node_comment_start,
    html_comment_node_children,
    html_comment_node_comment_end
  };

  return rb_class_new_instance(6, args, HTMLCommentNode);
};

static VALUE rb_html_doctype_node_from_c_struct(AST_HTML_DOCTYPE_NODE_T* html_doctype_node) {
  if (html_doctype_node == NULL) { return Qnil; }

  AST_NODE_T* node = &html_doctype_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE HTMLDoctypeNode = rb_define_class_under(AST, "HTMLDoctypeNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE html_doctype_node_tag_opening = rb_token_from_c_struct(html_doctype_node->tag_opening);
  VALUE html_doctype_node_children = rb_nodes_array_from_c_array(html_doctype_node->children);
  VALUE html_doctype_node_tag_closing = rb_token_from_c_struct(html_doctype_node->tag_closing);

  VALUE args[6] = {
    type,
    location,
    errors,
    html_doctype_node_tag_opening,
    html_doctype_node_children,
    html_doctype_node_tag_closing
  };

  return rb_class_new_instance(6, args, HTMLDoctypeNode);
};

static VALUE rb_xml_declaration_node_from_c_struct(AST_XML_DECLARATION_NODE_T* xml_declaration_node) {
  if (xml_declaration_node == NULL) { return Qnil; }

  AST_NODE_T* node = &xml_declaration_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE XMLDeclarationNode = rb_define_class_under(AST, "XMLDeclarationNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE xml_declaration_node_tag_opening = rb_token_from_c_struct(xml_declaration_node->tag_opening);
  VALUE xml_declaration_node_children = rb_nodes_array_from_c_array(xml_declaration_node->children);
  VALUE xml_declaration_node_tag_closing = rb_token_from_c_struct(xml_declaration_node->tag_closing);

  VALUE args[6] = {
    type,
    location,
    errors,
    xml_declaration_node_tag_opening,
    xml_declaration_node_children,
    xml_declaration_node_tag_closing
  };

  return rb_class_new_instance(6, args, XMLDeclarationNode);
};

static VALUE rb_cdata_node_from_c_struct(AST_CDATA_NODE_T* cdata_node) {
  if (cdata_node == NULL) { return Qnil; }

  AST_NODE_T* node = &cdata_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE CDATANode = rb_define_class_under(AST, "CDATANode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE cdata_node_tag_opening = rb_token_from_c_struct(cdata_node->tag_opening);
  VALUE cdata_node_children = rb_nodes_array_from_c_array(cdata_node->children);
  VALUE cdata_node_tag_closing = rb_token_from_c_struct(cdata_node->tag_closing);

  VALUE args[6] = {
    type,
    location,
    errors,
    cdata_node_tag_opening,
    cdata_node_children,
    cdata_node_tag_closing
  };

  return rb_class_new_instance(6, args, CDATANode);
};

static VALUE rb_whitespace_node_from_c_struct(AST_WHITESPACE_NODE_T* whitespace_node) {
  if (whitespace_node == NULL) { return Qnil; }

  AST_NODE_T* node = &whitespace_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE WhitespaceNode = rb_define_class_under(AST, "WhitespaceNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE whitespace_node_value = rb_token_from_c_struct(whitespace_node->value);

  VALUE args[4] = {
    type,
    location,
    errors,
    whitespace_node_value
  };

  return rb_class_new_instance(4, args, WhitespaceNode);
};

static VALUE rb_erb_content_node_from_c_struct(AST_ERB_CONTENT_NODE_T* erb_content_node) {
  if (erb_content_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_content_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBContentNode = rb_define_class_under(AST, "ERBContentNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_content_node_tag_opening = rb_token_from_c_struct(erb_content_node->tag_opening);
  VALUE erb_content_node_content = rb_token_from_c_struct(erb_content_node->content);
  VALUE erb_content_node_tag_closing = rb_token_from_c_struct(erb_content_node->tag_closing);
  /* #<Herb::Template::AnalyzedRubyField:0x00007f46a1d3cf40 @name="analyzed_ruby", @options={kind: nil}> */
  VALUE erb_content_node_analyzed_ruby = Qnil;
  VALUE erb_content_node_parsed = (erb_content_node->parsed) ? Qtrue : Qfalse;
  VALUE erb_content_node_valid = (erb_content_node->valid) ? Qtrue : Qfalse;

  VALUE args[9] = {
    type,
    location,
    errors,
    erb_content_node_tag_opening,
    erb_content_node_content,
    erb_content_node_tag_closing,
    erb_content_node_analyzed_ruby,
    erb_content_node_parsed,
    erb_content_node_valid
  };

  return rb_class_new_instance(9, args, ERBContentNode);
};

static VALUE rb_erb_end_node_from_c_struct(AST_ERB_END_NODE_T* erb_end_node) {
  if (erb_end_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_end_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBEndNode = rb_define_class_under(AST, "ERBEndNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_end_node_tag_opening = rb_token_from_c_struct(erb_end_node->tag_opening);
  VALUE erb_end_node_content = rb_token_from_c_struct(erb_end_node->content);
  VALUE erb_end_node_tag_closing = rb_token_from_c_struct(erb_end_node->tag_closing);

  VALUE args[6] = {
    type,
    location,
    errors,
    erb_end_node_tag_opening,
    erb_end_node_content,
    erb_end_node_tag_closing
  };

  return rb_class_new_instance(6, args, ERBEndNode);
};

static VALUE rb_erb_else_node_from_c_struct(AST_ERB_ELSE_NODE_T* erb_else_node) {
  if (erb_else_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_else_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBElseNode = rb_define_class_under(AST, "ERBElseNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_else_node_tag_opening = rb_token_from_c_struct(erb_else_node->tag_opening);
  VALUE erb_else_node_content = rb_token_from_c_struct(erb_else_node->content);
  VALUE erb_else_node_tag_closing = rb_token_from_c_struct(erb_else_node->tag_closing);
  VALUE erb_else_node_statements = rb_nodes_array_from_c_array(erb_else_node->statements);

  VALUE args[7] = {
    type,
    location,
    errors,
    erb_else_node_tag_opening,
    erb_else_node_content,
    erb_else_node_tag_closing,
    erb_else_node_statements
  };

  return rb_class_new_instance(7, args, ERBElseNode);
};

static VALUE rb_erb_if_node_from_c_struct(AST_ERB_IF_NODE_T* erb_if_node) {
  if (erb_if_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_if_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBIfNode = rb_define_class_under(AST, "ERBIfNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_if_node_tag_opening = rb_token_from_c_struct(erb_if_node->tag_opening);
  VALUE erb_if_node_content = rb_token_from_c_struct(erb_if_node->content);
  VALUE erb_if_node_tag_closing = rb_token_from_c_struct(erb_if_node->tag_closing);
  VALUE erb_if_node_statements = rb_nodes_array_from_c_array(erb_if_node->statements);
  VALUE erb_if_node_subsequent = rb_node_from_c_struct((AST_NODE_T*) erb_if_node->subsequent);
  VALUE erb_if_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_if_node->end_node);

  VALUE args[9] = {
    type,
    location,
    errors,
    erb_if_node_tag_opening,
    erb_if_node_content,
    erb_if_node_tag_closing,
    erb_if_node_statements,
    erb_if_node_subsequent,
    erb_if_node_end_node
  };

  return rb_class_new_instance(9, args, ERBIfNode);
};

static VALUE rb_erb_block_node_from_c_struct(AST_ERB_BLOCK_NODE_T* erb_block_node) {
  if (erb_block_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_block_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBBlockNode = rb_define_class_under(AST, "ERBBlockNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_block_node_tag_opening = rb_token_from_c_struct(erb_block_node->tag_opening);
  VALUE erb_block_node_content = rb_token_from_c_struct(erb_block_node->content);
  VALUE erb_block_node_tag_closing = rb_token_from_c_struct(erb_block_node->tag_closing);
  VALUE erb_block_node_body = rb_nodes_array_from_c_array(erb_block_node->body);
  VALUE erb_block_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_block_node->end_node);

  VALUE args[8] = {
    type,
    location,
    errors,
    erb_block_node_tag_opening,
    erb_block_node_content,
    erb_block_node_tag_closing,
    erb_block_node_body,
    erb_block_node_end_node
  };

  return rb_class_new_instance(8, args, ERBBlockNode);
};

static VALUE rb_erb_when_node_from_c_struct(AST_ERB_WHEN_NODE_T* erb_when_node) {
  if (erb_when_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_when_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBWhenNode = rb_define_class_under(AST, "ERBWhenNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_when_node_tag_opening = rb_token_from_c_struct(erb_when_node->tag_opening);
  VALUE erb_when_node_content = rb_token_from_c_struct(erb_when_node->content);
  VALUE erb_when_node_tag_closing = rb_token_from_c_struct(erb_when_node->tag_closing);
  VALUE erb_when_node_statements = rb_nodes_array_from_c_array(erb_when_node->statements);

  VALUE args[7] = {
    type,
    location,
    errors,
    erb_when_node_tag_opening,
    erb_when_node_content,
    erb_when_node_tag_closing,
    erb_when_node_statements
  };

  return rb_class_new_instance(7, args, ERBWhenNode);
};

static VALUE rb_erb_case_node_from_c_struct(AST_ERB_CASE_NODE_T* erb_case_node) {
  if (erb_case_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_case_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBCaseNode = rb_define_class_under(AST, "ERBCaseNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_case_node_tag_opening = rb_token_from_c_struct(erb_case_node->tag_opening);
  VALUE erb_case_node_content = rb_token_from_c_struct(erb_case_node->content);
  VALUE erb_case_node_tag_closing = rb_token_from_c_struct(erb_case_node->tag_closing);
  VALUE erb_case_node_children = rb_nodes_array_from_c_array(erb_case_node->children);
  VALUE erb_case_node_conditions = rb_nodes_array_from_c_array(erb_case_node->conditions);
  VALUE erb_case_node_else_clause = rb_node_from_c_struct((AST_NODE_T*) erb_case_node->else_clause);
  VALUE erb_case_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_case_node->end_node);

  VALUE args[10] = {
    type,
    location,
    errors,
    erb_case_node_tag_opening,
    erb_case_node_content,
    erb_case_node_tag_closing,
    erb_case_node_children,
    erb_case_node_conditions,
    erb_case_node_else_clause,
    erb_case_node_end_node
  };

  return rb_class_new_instance(10, args, ERBCaseNode);
};

static VALUE rb_erb_case_match_node_from_c_struct(AST_ERB_CASE_MATCH_NODE_T* erb_case_match_node) {
  if (erb_case_match_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_case_match_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBCaseMatchNode = rb_define_class_under(AST, "ERBCaseMatchNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_case_match_node_tag_opening = rb_token_from_c_struct(erb_case_match_node->tag_opening);
  VALUE erb_case_match_node_content = rb_token_from_c_struct(erb_case_match_node->content);
  VALUE erb_case_match_node_tag_closing = rb_token_from_c_struct(erb_case_match_node->tag_closing);
  VALUE erb_case_match_node_children = rb_nodes_array_from_c_array(erb_case_match_node->children);
  VALUE erb_case_match_node_conditions = rb_nodes_array_from_c_array(erb_case_match_node->conditions);
  VALUE erb_case_match_node_else_clause = rb_node_from_c_struct((AST_NODE_T*) erb_case_match_node->else_clause);
  VALUE erb_case_match_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_case_match_node->end_node);

  VALUE args[10] = {
    type,
    location,
    errors,
    erb_case_match_node_tag_opening,
    erb_case_match_node_content,
    erb_case_match_node_tag_closing,
    erb_case_match_node_children,
    erb_case_match_node_conditions,
    erb_case_match_node_else_clause,
    erb_case_match_node_end_node
  };

  return rb_class_new_instance(10, args, ERBCaseMatchNode);
};

static VALUE rb_erb_while_node_from_c_struct(AST_ERB_WHILE_NODE_T* erb_while_node) {
  if (erb_while_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_while_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBWhileNode = rb_define_class_under(AST, "ERBWhileNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_while_node_tag_opening = rb_token_from_c_struct(erb_while_node->tag_opening);
  VALUE erb_while_node_content = rb_token_from_c_struct(erb_while_node->content);
  VALUE erb_while_node_tag_closing = rb_token_from_c_struct(erb_while_node->tag_closing);
  VALUE erb_while_node_statements = rb_nodes_array_from_c_array(erb_while_node->statements);
  VALUE erb_while_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_while_node->end_node);

  VALUE args[8] = {
    type,
    location,
    errors,
    erb_while_node_tag_opening,
    erb_while_node_content,
    erb_while_node_tag_closing,
    erb_while_node_statements,
    erb_while_node_end_node
  };

  return rb_class_new_instance(8, args, ERBWhileNode);
};

static VALUE rb_erb_until_node_from_c_struct(AST_ERB_UNTIL_NODE_T* erb_until_node) {
  if (erb_until_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_until_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBUntilNode = rb_define_class_under(AST, "ERBUntilNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_until_node_tag_opening = rb_token_from_c_struct(erb_until_node->tag_opening);
  VALUE erb_until_node_content = rb_token_from_c_struct(erb_until_node->content);
  VALUE erb_until_node_tag_closing = rb_token_from_c_struct(erb_until_node->tag_closing);
  VALUE erb_until_node_statements = rb_nodes_array_from_c_array(erb_until_node->statements);
  VALUE erb_until_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_until_node->end_node);

  VALUE args[8] = {
    type,
    location,
    errors,
    erb_until_node_tag_opening,
    erb_until_node_content,
    erb_until_node_tag_closing,
    erb_until_node_statements,
    erb_until_node_end_node
  };

  return rb_class_new_instance(8, args, ERBUntilNode);
};

static VALUE rb_erb_for_node_from_c_struct(AST_ERB_FOR_NODE_T* erb_for_node) {
  if (erb_for_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_for_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBForNode = rb_define_class_under(AST, "ERBForNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_for_node_tag_opening = rb_token_from_c_struct(erb_for_node->tag_opening);
  VALUE erb_for_node_content = rb_token_from_c_struct(erb_for_node->content);
  VALUE erb_for_node_tag_closing = rb_token_from_c_struct(erb_for_node->tag_closing);
  VALUE erb_for_node_statements = rb_nodes_array_from_c_array(erb_for_node->statements);
  VALUE erb_for_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_for_node->end_node);

  VALUE args[8] = {
    type,
    location,
    errors,
    erb_for_node_tag_opening,
    erb_for_node_content,
    erb_for_node_tag_closing,
    erb_for_node_statements,
    erb_for_node_end_node
  };

  return rb_class_new_instance(8, args, ERBForNode);
};

static VALUE rb_erb_rescue_node_from_c_struct(AST_ERB_RESCUE_NODE_T* erb_rescue_node) {
  if (erb_rescue_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_rescue_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBRescueNode = rb_define_class_under(AST, "ERBRescueNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_rescue_node_tag_opening = rb_token_from_c_struct(erb_rescue_node->tag_opening);
  VALUE erb_rescue_node_content = rb_token_from_c_struct(erb_rescue_node->content);
  VALUE erb_rescue_node_tag_closing = rb_token_from_c_struct(erb_rescue_node->tag_closing);
  VALUE erb_rescue_node_statements = rb_nodes_array_from_c_array(erb_rescue_node->statements);
  VALUE erb_rescue_node_subsequent = rb_node_from_c_struct((AST_NODE_T*) erb_rescue_node->subsequent);

  VALUE args[8] = {
    type,
    location,
    errors,
    erb_rescue_node_tag_opening,
    erb_rescue_node_content,
    erb_rescue_node_tag_closing,
    erb_rescue_node_statements,
    erb_rescue_node_subsequent
  };

  return rb_class_new_instance(8, args, ERBRescueNode);
};

static VALUE rb_erb_ensure_node_from_c_struct(AST_ERB_ENSURE_NODE_T* erb_ensure_node) {
  if (erb_ensure_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_ensure_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBEnsureNode = rb_define_class_under(AST, "ERBEnsureNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_ensure_node_tag_opening = rb_token_from_c_struct(erb_ensure_node->tag_opening);
  VALUE erb_ensure_node_content = rb_token_from_c_struct(erb_ensure_node->content);
  VALUE erb_ensure_node_tag_closing = rb_token_from_c_struct(erb_ensure_node->tag_closing);
  VALUE erb_ensure_node_statements = rb_nodes_array_from_c_array(erb_ensure_node->statements);

  VALUE args[7] = {
    type,
    location,
    errors,
    erb_ensure_node_tag_opening,
    erb_ensure_node_content,
    erb_ensure_node_tag_closing,
    erb_ensure_node_statements
  };

  return rb_class_new_instance(7, args, ERBEnsureNode);
};

static VALUE rb_erb_begin_node_from_c_struct(AST_ERB_BEGIN_NODE_T* erb_begin_node) {
  if (erb_begin_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_begin_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBBeginNode = rb_define_class_under(AST, "ERBBeginNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_begin_node_tag_opening = rb_token_from_c_struct(erb_begin_node->tag_opening);
  VALUE erb_begin_node_content = rb_token_from_c_struct(erb_begin_node->content);
  VALUE erb_begin_node_tag_closing = rb_token_from_c_struct(erb_begin_node->tag_closing);
  VALUE erb_begin_node_statements = rb_nodes_array_from_c_array(erb_begin_node->statements);
  VALUE erb_begin_node_rescue_clause = rb_node_from_c_struct((AST_NODE_T*) erb_begin_node->rescue_clause);
  VALUE erb_begin_node_else_clause = rb_node_from_c_struct((AST_NODE_T*) erb_begin_node->else_clause);
  VALUE erb_begin_node_ensure_clause = rb_node_from_c_struct((AST_NODE_T*) erb_begin_node->ensure_clause);
  VALUE erb_begin_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_begin_node->end_node);

  VALUE args[11] = {
    type,
    location,
    errors,
    erb_begin_node_tag_opening,
    erb_begin_node_content,
    erb_begin_node_tag_closing,
    erb_begin_node_statements,
    erb_begin_node_rescue_clause,
    erb_begin_node_else_clause,
    erb_begin_node_ensure_clause,
    erb_begin_node_end_node
  };

  return rb_class_new_instance(11, args, ERBBeginNode);
};

static VALUE rb_erb_unless_node_from_c_struct(AST_ERB_UNLESS_NODE_T* erb_unless_node) {
  if (erb_unless_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_unless_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBUnlessNode = rb_define_class_under(AST, "ERBUnlessNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_unless_node_tag_opening = rb_token_from_c_struct(erb_unless_node->tag_opening);
  VALUE erb_unless_node_content = rb_token_from_c_struct(erb_unless_node->content);
  VALUE erb_unless_node_tag_closing = rb_token_from_c_struct(erb_unless_node->tag_closing);
  VALUE erb_unless_node_statements = rb_nodes_array_from_c_array(erb_unless_node->statements);
  VALUE erb_unless_node_else_clause = rb_node_from_c_struct((AST_NODE_T*) erb_unless_node->else_clause);
  VALUE erb_unless_node_end_node = rb_node_from_c_struct((AST_NODE_T*) erb_unless_node->end_node);

  VALUE args[9] = {
    type,
    location,
    errors,
    erb_unless_node_tag_opening,
    erb_unless_node_content,
    erb_unless_node_tag_closing,
    erb_unless_node_statements,
    erb_unless_node_else_clause,
    erb_unless_node_end_node
  };

  return rb_class_new_instance(9, args, ERBUnlessNode);
};

static VALUE rb_erb_yield_node_from_c_struct(AST_ERB_YIELD_NODE_T* erb_yield_node) {
  if (erb_yield_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_yield_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBYieldNode = rb_define_class_under(AST, "ERBYieldNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_yield_node_tag_opening = rb_token_from_c_struct(erb_yield_node->tag_opening);
  VALUE erb_yield_node_content = rb_token_from_c_struct(erb_yield_node->content);
  VALUE erb_yield_node_tag_closing = rb_token_from_c_struct(erb_yield_node->tag_closing);

  VALUE args[6] = {
    type,
    location,
    errors,
    erb_yield_node_tag_opening,
    erb_yield_node_content,
    erb_yield_node_tag_closing
  };

  return rb_class_new_instance(6, args, ERBYieldNode);
};

static VALUE rb_erb_in_node_from_c_struct(AST_ERB_IN_NODE_T* erb_in_node) {
  if (erb_in_node == NULL) { return Qnil; }

  AST_NODE_T* node = &erb_in_node->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE AST = rb_define_module_under(Herb, "AST");
  VALUE Node = rb_define_class_under(AST, "Node", rb_cObject);
  VALUE ERBInNode = rb_define_class_under(AST, "ERBInNode", Node);

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  VALUE erb_in_node_tag_opening = rb_token_from_c_struct(erb_in_node->tag_opening);
  VALUE erb_in_node_content = rb_token_from_c_struct(erb_in_node->content);
  VALUE erb_in_node_tag_closing = rb_token_from_c_struct(erb_in_node->tag_closing);
  VALUE erb_in_node_statements = rb_nodes_array_from_c_array(erb_in_node->statements);

  VALUE args[7] = {
    type,
    location,
    errors,
    erb_in_node_tag_opening,
    erb_in_node_content,
    erb_in_node_tag_closing,
    erb_in_node_statements
  };

  return rb_class_new_instance(7, args, ERBInNode);
};


VALUE rb_node_from_c_struct(AST_NODE_T* node) {
  if (!node) { return Qnil; }

  switch (node->type) {
    case AST_DOCUMENT_NODE: return rb_document_node_from_c_struct((AST_DOCUMENT_NODE_T*) node); break;
    case AST_LITERAL_NODE: return rb_literal_node_from_c_struct((AST_LITERAL_NODE_T*) node); break;
    case AST_HTML_OPEN_TAG_NODE: return rb_html_open_tag_node_from_c_struct((AST_HTML_OPEN_TAG_NODE_T*) node); break;
    case AST_HTML_CLOSE_TAG_NODE: return rb_html_close_tag_node_from_c_struct((AST_HTML_CLOSE_TAG_NODE_T*) node); break;
    case AST_HTML_ELEMENT_NODE: return rb_html_element_node_from_c_struct((AST_HTML_ELEMENT_NODE_T*) node); break;
    case AST_HTML_ATTRIBUTE_VALUE_NODE: return rb_html_attribute_value_node_from_c_struct((AST_HTML_ATTRIBUTE_VALUE_NODE_T*) node); break;
    case AST_HTML_ATTRIBUTE_NAME_NODE: return rb_html_attribute_name_node_from_c_struct((AST_HTML_ATTRIBUTE_NAME_NODE_T*) node); break;
    case AST_HTML_ATTRIBUTE_NODE: return rb_html_attribute_node_from_c_struct((AST_HTML_ATTRIBUTE_NODE_T*) node); break;
    case AST_HTML_TEXT_NODE: return rb_html_text_node_from_c_struct((AST_HTML_TEXT_NODE_T*) node); break;
    case AST_HTML_COMMENT_NODE: return rb_html_comment_node_from_c_struct((AST_HTML_COMMENT_NODE_T*) node); break;
    case AST_HTML_DOCTYPE_NODE: return rb_html_doctype_node_from_c_struct((AST_HTML_DOCTYPE_NODE_T*) node); break;
    case AST_XML_DECLARATION_NODE: return rb_xml_declaration_node_from_c_struct((AST_XML_DECLARATION_NODE_T*) node); break;
    case AST_CDATA_NODE: return rb_cdata_node_from_c_struct((AST_CDATA_NODE_T*) node); break;
    case AST_WHITESPACE_NODE: return rb_whitespace_node_from_c_struct((AST_WHITESPACE_NODE_T*) node); break;
    case AST_ERB_CONTENT_NODE: return rb_erb_content_node_from_c_struct((AST_ERB_CONTENT_NODE_T*) node); break;
    case AST_ERB_END_NODE: return rb_erb_end_node_from_c_struct((AST_ERB_END_NODE_T*) node); break;
    case AST_ERB_ELSE_NODE: return rb_erb_else_node_from_c_struct((AST_ERB_ELSE_NODE_T*) node); break;
    case AST_ERB_IF_NODE: return rb_erb_if_node_from_c_struct((AST_ERB_IF_NODE_T*) node); break;
    case AST_ERB_BLOCK_NODE: return rb_erb_block_node_from_c_struct((AST_ERB_BLOCK_NODE_T*) node); break;
    case AST_ERB_WHEN_NODE: return rb_erb_when_node_from_c_struct((AST_ERB_WHEN_NODE_T*) node); break;
    case AST_ERB_CASE_NODE: return rb_erb_case_node_from_c_struct((AST_ERB_CASE_NODE_T*) node); break;
    case AST_ERB_CASE_MATCH_NODE: return rb_erb_case_match_node_from_c_struct((AST_ERB_CASE_MATCH_NODE_T*) node); break;
    case AST_ERB_WHILE_NODE: return rb_erb_while_node_from_c_struct((AST_ERB_WHILE_NODE_T*) node); break;
    case AST_ERB_UNTIL_NODE: return rb_erb_until_node_from_c_struct((AST_ERB_UNTIL_NODE_T*) node); break;
    case AST_ERB_FOR_NODE: return rb_erb_for_node_from_c_struct((AST_ERB_FOR_NODE_T*) node); break;
    case AST_ERB_RESCUE_NODE: return rb_erb_rescue_node_from_c_struct((AST_ERB_RESCUE_NODE_T*) node); break;
    case AST_ERB_ENSURE_NODE: return rb_erb_ensure_node_from_c_struct((AST_ERB_ENSURE_NODE_T*) node); break;
    case AST_ERB_BEGIN_NODE: return rb_erb_begin_node_from_c_struct((AST_ERB_BEGIN_NODE_T*) node); break;
    case AST_ERB_UNLESS_NODE: return rb_erb_unless_node_from_c_struct((AST_ERB_UNLESS_NODE_T*) node); break;
    case AST_ERB_YIELD_NODE: return rb_erb_yield_node_from_c_struct((AST_ERB_YIELD_NODE_T*) node); break;
    case AST_ERB_IN_NODE: return rb_erb_in_node_from_c_struct((AST_ERB_IN_NODE_T*) node); break;
  }

  return Qnil;
}

static VALUE rb_nodes_array_from_c_array(hb_array_T* array) {
  VALUE rb_array = rb_ary_new();

  if (array) {
    for (size_t i = 0; i < array->size; i++) {
      AST_NODE_T* child_node = (AST_NODE_T*) hb_array_get(array, i);

      if (child_node) {
        VALUE rb_child = rb_node_from_c_struct(child_node);
        rb_ary_push(rb_array, rb_child);
      }
    }
  }

  return rb_array;
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/ext/herb/error_helpers.c.erb

#include <ruby.h>

#include "extension.h"
#include "extension_helpers.h"
#include "error_helpers.h"

#include "../../src/include/errors.h"
#include "../../src/include/herb.h"
#include "../../src/include/token.h"

VALUE rb_error_from_c_struct(ERROR_T* error);

static VALUE rb_unexpected_error_from_c_struct(UNEXPECTED_ERROR_T* unexpected_error) {
  if (unexpected_error == NULL) { return Qnil; }

  ERROR_T* error = &unexpected_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE UnexpectedError = rb_define_class_under(Errors, "UnexpectedError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE unexpected_error_description = rb_utf8_str_new_cstr(unexpected_error->description);
  VALUE unexpected_error_expected = rb_utf8_str_new_cstr(unexpected_error->expected);
  VALUE unexpected_error_found = rb_utf8_str_new_cstr(unexpected_error->found);

  VALUE args[6] = {
    type,
    location,
    message,
    unexpected_error_description,
    unexpected_error_expected,
    unexpected_error_found
  };

  return rb_class_new_instance(6, args, UnexpectedError);
};

static VALUE rb_unexpected_token_error_from_c_struct(UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error) {
  if (unexpected_token_error == NULL) { return Qnil; }

  ERROR_T* error = &unexpected_token_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE UnexpectedTokenError = rb_define_class_under(Errors, "UnexpectedTokenError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE unexpected_token_error_expected_type = rb_utf8_str_new_cstr(token_type_to_string(unexpected_token_error->expected_type));
  VALUE unexpected_token_error_found = rb_token_from_c_struct(unexpected_token_error->found);

  VALUE args[5] = {
    type,
    location,
    message,
    unexpected_token_error_expected_type,
    unexpected_token_error_found
  };

  return rb_class_new_instance(5, args, UnexpectedTokenError);
};

static VALUE rb_missing_opening_tag_error_from_c_struct(MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error) {
  if (missing_opening_tag_error == NULL) { return Qnil; }

  ERROR_T* error = &missing_opening_tag_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE MissingOpeningTagError = rb_define_class_under(Errors, "MissingOpeningTagError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE missing_opening_tag_error_closing_tag = rb_token_from_c_struct(missing_opening_tag_error->closing_tag);

  VALUE args[4] = {
    type,
    location,
    message,
    missing_opening_tag_error_closing_tag
  };

  return rb_class_new_instance(4, args, MissingOpeningTagError);
};

static VALUE rb_missing_closing_tag_error_from_c_struct(MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error) {
  if (missing_closing_tag_error == NULL) { return Qnil; }

  ERROR_T* error = &missing_closing_tag_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE MissingClosingTagError = rb_define_class_under(Errors, "MissingClosingTagError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE missing_closing_tag_error_opening_tag = rb_token_from_c_struct(missing_closing_tag_error->opening_tag);

  VALUE args[4] = {
    type,
    location,
    message,
    missing_closing_tag_error_opening_tag
  };

  return rb_class_new_instance(4, args, MissingClosingTagError);
};

static VALUE rb_tag_names_mismatch_error_from_c_struct(TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error) {
  if (tag_names_mismatch_error == NULL) { return Qnil; }

  ERROR_T* error = &tag_names_mismatch_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE TagNamesMismatchError = rb_define_class_under(Errors, "TagNamesMismatchError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE tag_names_mismatch_error_opening_tag = rb_token_from_c_struct(tag_names_mismatch_error->opening_tag);
  VALUE tag_names_mismatch_error_closing_tag = rb_token_from_c_struct(tag_names_mismatch_error->closing_tag);

  VALUE args[5] = {
    type,
    location,
    message,
    tag_names_mismatch_error_opening_tag,
    tag_names_mismatch_error_closing_tag
  };

  return rb_class_new_instance(5, args, TagNamesMismatchError);
};

static VALUE rb_quotes_mismatch_error_from_c_struct(QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error) {
  if (quotes_mismatch_error == NULL) { return Qnil; }

  ERROR_T* error = &quotes_mismatch_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE QuotesMismatchError = rb_define_class_under(Errors, "QuotesMismatchError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE quotes_mismatch_error_opening_quote = rb_token_from_c_struct(quotes_mismatch_error->opening_quote);
  VALUE quotes_mismatch_error_closing_quote = rb_token_from_c_struct(quotes_mismatch_error->closing_quote);

  VALUE args[5] = {
    type,
    location,
    message,
    quotes_mismatch_error_opening_quote,
    quotes_mismatch_error_closing_quote
  };

  return rb_class_new_instance(5, args, QuotesMismatchError);
};

static VALUE rb_void_element_closing_tag_error_from_c_struct(VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error) {
  if (void_element_closing_tag_error == NULL) { return Qnil; }

  ERROR_T* error = &void_element_closing_tag_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE VoidElementClosingTagError = rb_define_class_under(Errors, "VoidElementClosingTagError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE void_element_closing_tag_error_tag_name = rb_token_from_c_struct(void_element_closing_tag_error->tag_name);
  VALUE void_element_closing_tag_error_expected = rb_utf8_str_new_cstr(void_element_closing_tag_error->expected);
  VALUE void_element_closing_tag_error_found = rb_utf8_str_new_cstr(void_element_closing_tag_error->found);

  VALUE args[6] = {
    type,
    location,
    message,
    void_element_closing_tag_error_tag_name,
    void_element_closing_tag_error_expected,
    void_element_closing_tag_error_found
  };

  return rb_class_new_instance(6, args, VoidElementClosingTagError);
};

static VALUE rb_unclosed_element_error_from_c_struct(UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error) {
  if (unclosed_element_error == NULL) { return Qnil; }

  ERROR_T* error = &unclosed_element_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE UnclosedElementError = rb_define_class_under(Errors, "UnclosedElementError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE unclosed_element_error_opening_tag = rb_token_from_c_struct(unclosed_element_error->opening_tag);

  VALUE args[4] = {
    type,
    location,
    message,
    unclosed_element_error_opening_tag
  };

  return rb_class_new_instance(4, args, UnclosedElementError);
};

static VALUE rb_ruby_parse_error_from_c_struct(RUBY_PARSE_ERROR_T* ruby_parse_error) {
  if (ruby_parse_error == NULL) { return Qnil; }

  ERROR_T* error = &ruby_parse_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE RubyParseError = rb_define_class_under(Errors, "RubyParseError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE ruby_parse_error_error_message = rb_utf8_str_new_cstr(ruby_parse_error->error_message);
  VALUE ruby_parse_error_diagnostic_id = rb_utf8_str_new_cstr(ruby_parse_error->diagnostic_id);
  VALUE ruby_parse_error_level = rb_utf8_str_new_cstr(ruby_parse_error->level);

  VALUE args[6] = {
    type,
    location,
    message,
    ruby_parse_error_error_message,
    ruby_parse_error_diagnostic_id,
    ruby_parse_error_level
  };

  return rb_class_new_instance(6, args, RubyParseError);
};

static VALUE rb_erb_control_flow_scope_error_from_c_struct(ERB_CONTROL_FLOW_SCOPE_ERROR_T* erb_control_flow_scope_error) {
  if (erb_control_flow_scope_error == NULL) { return Qnil; }

  ERROR_T* error = &erb_control_flow_scope_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE ERBControlFlowScopeError = rb_define_class_under(Errors, "ERBControlFlowScopeError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE erb_control_flow_scope_error_keyword = rb_utf8_str_new_cstr(erb_control_flow_scope_error->keyword);

  VALUE args[4] = {
    type,
    location,
    message,
    erb_control_flow_scope_error_keyword
  };

  return rb_class_new_instance(4, args, ERBControlFlowScopeError);
};

static VALUE rb_missingerb_end_tag_error_from_c_struct(MISSINGERB_END_TAG_ERROR_T* missingerb_end_tag_error) {
  if (missingerb_end_tag_error == NULL) { return Qnil; }

  ERROR_T* error = &missingerb_end_tag_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE MissingERBEndTagError = rb_define_class_under(Errors, "MissingERBEndTagError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);

  VALUE missingerb_end_tag_error_keyword = rb_utf8_str_new_cstr(missingerb_end_tag_error->keyword);

  VALUE args[4] = {
    type,
    location,
    message,
    missingerb_end_tag_error_keyword
  };

  return rb_class_new_instance(4, args, MissingERBEndTagError);
};

static VALUE rb_erb_multiple_blocks_in_tag_error_from_c_struct(ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T* erb_multiple_blocks_in_tag_error) {
  if (erb_multiple_blocks_in_tag_error == NULL) { return Qnil; }

  ERROR_T* error = &erb_multiple_blocks_in_tag_error->base;

  VALUE Herb = rb_define_module("Herb");
  VALUE Errors = rb_define_module_under(Herb, "Errors");
  VALUE Error = rb_define_class_under(Errors, "Error", rb_cObject);
  VALUE ERBMultipleBlocksInTagError = rb_define_class_under(Errors, "ERBMultipleBlocksInTagError", Error);

  VALUE type = rb_utf8_str_new_cstr(error_type_to_string(error));
  VALUE location = rb_location_from_c_struct(error->location);
  VALUE message = rb_utf8_str_new_cstr(error->message);


  VALUE args[3] = {
    type,
    location,
    message
  };

  return rb_class_new_instance(3, args, ERBMultipleBlocksInTagError);
};


VALUE rb_error_from_c_struct(ERROR_T* error) {
  if (!error) { return Qnil; }

  switch (error->type) {
    case UNEXPECTED_ERROR: return rb_unexpected_error_from_c_struct((UNEXPECTED_ERROR_T*) error); break;
    case UNEXPECTED_TOKEN_ERROR: return rb_unexpected_token_error_from_c_struct((UNEXPECTED_TOKEN_ERROR_T*) error); break;
    case MISSING_OPENING_TAG_ERROR: return rb_missing_opening_tag_error_from_c_struct((MISSING_OPENING_TAG_ERROR_T*) error); break;
    case MISSING_CLOSING_TAG_ERROR: return rb_missing_closing_tag_error_from_c_struct((MISSING_CLOSING_TAG_ERROR_T*) error); break;
    case TAG_NAMES_MISMATCH_ERROR: return rb_tag_names_mismatch_error_from_c_struct((TAG_NAMES_MISMATCH_ERROR_T*) error); break;
    case QUOTES_MISMATCH_ERROR: return rb_quotes_mismatch_error_from_c_struct((QUOTES_MISMATCH_ERROR_T*) error); break;
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return rb_void_element_closing_tag_error_from_c_struct((VOID_ELEMENT_CLOSING_TAG_ERROR_T*) error); break;
    case UNCLOSED_ELEMENT_ERROR: return rb_unclosed_element_error_from_c_struct((UNCLOSED_ELEMENT_ERROR_T*) error); break;
    case RUBY_PARSE_ERROR: return rb_ruby_parse_error_from_c_struct((RUBY_PARSE_ERROR_T*) error); break;
    case ERB_CONTROL_FLOW_SCOPE_ERROR: return rb_erb_control_flow_scope_error_from_c_struct((ERB_CONTROL_FLOW_SCOPE_ERROR_T*) error); break;
    case MISSINGERB_END_TAG_ERROR: return rb_missingerb_end_tag_error_from_c_struct((MISSINGERB_END_TAG_ERROR_T*) error); break;
    case ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR: return rb_erb_multiple_blocks_in_tag_error_from_c_struct((ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T*) error); break;
  }

  return Qnil;
}

VALUE rb_errors_array_from_c_array(hb_array_T* array) {
  VALUE rb_array = rb_ary_new();

  if (array) {
    for (size_t i = 0; i < array->size; i++) {
      ERROR_T* child_node = (ERROR_T*) hb_array_get(array, i);

      if (child_node) {
        VALUE rb_child = rb_error_from_c_struct(child_node);
        rb_ary_push(rb_array, rb_child);
      }
    }
  }

  return rb_array;
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/src/parser_match_tags.c.erb

#include "include/parser.h"
#include "include/ast_nodes.h"
#include "include/util/hb_array.h"
#include "include/visitor.h"

bool match_tags_visitor(const AST_NODE_T* node, void* data) {
  hb_array_T* errors = (hb_array_T*) data;

  if (node == NULL) { return false; }

  switch (node->type) {

    case AST_DOCUMENT_NODE: {
      const AST_DOCUMENT_NODE_T* document_node = (const AST_DOCUMENT_NODE_T*) node;

      if (document_node->children != NULL) {
        match_tags_in_node_array(document_node->children, errors);
      }
    } break;



    case AST_HTML_OPEN_TAG_NODE: {
      const AST_HTML_OPEN_TAG_NODE_T* html_open_tag_node = (const AST_HTML_OPEN_TAG_NODE_T*) node;

      if (html_open_tag_node->children != NULL) {
        match_tags_in_node_array(html_open_tag_node->children, errors);
      }
    } break;


    case AST_HTML_CLOSE_TAG_NODE: {
      const AST_HTML_CLOSE_TAG_NODE_T* html_close_tag_node = (const AST_HTML_CLOSE_TAG_NODE_T*) node;

      if (html_close_tag_node->children != NULL) {
        match_tags_in_node_array(html_close_tag_node->children, errors);
      }
    } break;


    case AST_HTML_ELEMENT_NODE: {
      const AST_HTML_ELEMENT_NODE_T* html_element_node = (const AST_HTML_ELEMENT_NODE_T*) node;

      if (html_element_node->body != NULL) {
        match_tags_in_node_array(html_element_node->body, errors);
      }
      if (html_element_node->open_tag != NULL) {
        herb_visit_node((AST_NODE_T*) html_element_node->open_tag, match_tags_visitor, errors);
      }
      if (html_element_node->close_tag != NULL) {
        herb_visit_node((AST_NODE_T*) html_element_node->close_tag, match_tags_visitor, errors);
      }
    } break;


    case AST_HTML_ATTRIBUTE_VALUE_NODE: {
      const AST_HTML_ATTRIBUTE_VALUE_NODE_T* html_attribute_value_node = (const AST_HTML_ATTRIBUTE_VALUE_NODE_T*) node;

      if (html_attribute_value_node->children != NULL) {
        match_tags_in_node_array(html_attribute_value_node->children, errors);
      }
    } break;


    case AST_HTML_ATTRIBUTE_NAME_NODE: {
      const AST_HTML_ATTRIBUTE_NAME_NODE_T* html_attribute_name_node = (const AST_HTML_ATTRIBUTE_NAME_NODE_T*) node;

      if (html_attribute_name_node->children != NULL) {
        match_tags_in_node_array(html_attribute_name_node->children, errors);
      }
    } break;


    case AST_HTML_ATTRIBUTE_NODE: {
      const AST_HTML_ATTRIBUTE_NODE_T* html_attribute_node = (const AST_HTML_ATTRIBUTE_NODE_T*) node;

      if (html_attribute_node->name != NULL) {
        herb_visit_node((AST_NODE_T*) html_attribute_node->name, match_tags_visitor, errors);
      }
      if (html_attribute_node->value != NULL) {
        herb_visit_node((AST_NODE_T*) html_attribute_node->value, match_tags_visitor, errors);
      }
    } break;



    case AST_HTML_COMMENT_NODE: {
      const AST_HTML_COMMENT_NODE_T* html_comment_node = (const AST_HTML_COMMENT_NODE_T*) node;

      if (html_comment_node->children != NULL) {
        match_tags_in_node_array(html_comment_node->children, errors);
      }
    } break;


    case AST_HTML_DOCTYPE_NODE: {
      const AST_HTML_DOCTYPE_NODE_T* html_doctype_node = (const AST_HTML_DOCTYPE_NODE_T*) node;

      if (html_doctype_node->children != NULL) {
        match_tags_in_node_array(html_doctype_node->children, errors);
      }
    } break;


    case AST_XML_DECLARATION_NODE: {
      const AST_XML_DECLARATION_NODE_T* xml_declaration_node = (const AST_XML_DECLARATION_NODE_T*) node;

      if (xml_declaration_node->children != NULL) {
        match_tags_in_node_array(xml_declaration_node->children, errors);
      }
    } break;


    case AST_CDATA_NODE: {
      const AST_CDATA_NODE_T* cdata_node = (const AST_CDATA_NODE_T*) node;

      if (cdata_node->children != NULL) {
        match_tags_in_node_array(cdata_node->children, errors);
      }
    } break;





    case AST_ERB_ELSE_NODE: {
      const AST_ERB_ELSE_NODE_T* erb_else_node = (const AST_ERB_ELSE_NODE_T*) node;

      if (erb_else_node->statements != NULL) {
        match_tags_in_node_array(erb_else_node->statements, errors);
      }
    } break;


    case AST_ERB_IF_NODE: {
      const AST_ERB_IF_NODE_T* erb_if_node = (const AST_ERB_IF_NODE_T*) node;

      if (erb_if_node->statements != NULL) {
        match_tags_in_node_array(erb_if_node->statements, errors);
      }
      if (erb_if_node->subsequent != NULL) {
        herb_visit_node((AST_NODE_T*) erb_if_node->subsequent, match_tags_visitor, errors);
      }
      if (erb_if_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_if_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_BLOCK_NODE: {
      const AST_ERB_BLOCK_NODE_T* erb_block_node = (const AST_ERB_BLOCK_NODE_T*) node;

      if (erb_block_node->body != NULL) {
        match_tags_in_node_array(erb_block_node->body, errors);
      }
      if (erb_block_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_block_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_WHEN_NODE: {
      const AST_ERB_WHEN_NODE_T* erb_when_node = (const AST_ERB_WHEN_NODE_T*) node;

      if (erb_when_node->statements != NULL) {
        match_tags_in_node_array(erb_when_node->statements, errors);
      }
    } break;


    case AST_ERB_CASE_NODE: {
      const AST_ERB_CASE_NODE_T* erb_case_node = (const AST_ERB_CASE_NODE_T*) node;

      if (erb_case_node->children != NULL) {
        match_tags_in_node_array(erb_case_node->children, errors);
      }
      if (erb_case_node->conditions != NULL) {
        match_tags_in_node_array(erb_case_node->conditions, errors);
      }
      if (erb_case_node->else_clause != NULL) {
        herb_visit_node((AST_NODE_T*) erb_case_node->else_clause, match_tags_visitor, errors);
      }
      if (erb_case_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_case_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_CASE_MATCH_NODE: {
      const AST_ERB_CASE_MATCH_NODE_T* erb_case_match_node = (const AST_ERB_CASE_MATCH_NODE_T*) node;

      if (erb_case_match_node->children != NULL) {
        match_tags_in_node_array(erb_case_match_node->children, errors);
      }
      if (erb_case_match_node->conditions != NULL) {
        match_tags_in_node_array(erb_case_match_node->conditions, errors);
      }
      if (erb_case_match_node->else_clause != NULL) {
        herb_visit_node((AST_NODE_T*) erb_case_match_node->else_clause, match_tags_visitor, errors);
      }
      if (erb_case_match_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_case_match_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_WHILE_NODE: {
      const AST_ERB_WHILE_NODE_T* erb_while_node = (const AST_ERB_WHILE_NODE_T*) node;

      if (erb_while_node->statements != NULL) {
        match_tags_in_node_array(erb_while_node->statements, errors);
      }
      if (erb_while_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_while_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_UNTIL_NODE: {
      const AST_ERB_UNTIL_NODE_T* erb_until_node = (const AST_ERB_UNTIL_NODE_T*) node;

      if (erb_until_node->statements != NULL) {
        match_tags_in_node_array(erb_until_node->statements, errors);
      }
      if (erb_until_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_until_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_FOR_NODE: {
      const AST_ERB_FOR_NODE_T* erb_for_node = (const AST_ERB_FOR_NODE_T*) node;

      if (erb_for_node->statements != NULL) {
        match_tags_in_node_array(erb_for_node->statements, errors);
      }
      if (erb_for_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_for_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_RESCUE_NODE: {
      const AST_ERB_RESCUE_NODE_T* erb_rescue_node = (const AST_ERB_RESCUE_NODE_T*) node;

      if (erb_rescue_node->statements != NULL) {
        match_tags_in_node_array(erb_rescue_node->statements, errors);
      }
      if (erb_rescue_node->subsequent != NULL) {
        herb_visit_node((AST_NODE_T*) erb_rescue_node->subsequent, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_ENSURE_NODE: {
      const AST_ERB_ENSURE_NODE_T* erb_ensure_node = (const AST_ERB_ENSURE_NODE_T*) node;

      if (erb_ensure_node->statements != NULL) {
        match_tags_in_node_array(erb_ensure_node->statements, errors);
      }
    } break;


    case AST_ERB_BEGIN_NODE: {
      const AST_ERB_BEGIN_NODE_T* erb_begin_node = (const AST_ERB_BEGIN_NODE_T*) node;

      if (erb_begin_node->statements != NULL) {
        match_tags_in_node_array(erb_begin_node->statements, errors);
      }
      if (erb_begin_node->rescue_clause != NULL) {
        herb_visit_node((AST_NODE_T*) erb_begin_node->rescue_clause, match_tags_visitor, errors);
      }
      if (erb_begin_node->else_clause != NULL) {
        herb_visit_node((AST_NODE_T*) erb_begin_node->else_clause, match_tags_visitor, errors);
      }
      if (erb_begin_node->ensure_clause != NULL) {
        herb_visit_node((AST_NODE_T*) erb_begin_node->ensure_clause, match_tags_visitor, errors);
      }
      if (erb_begin_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_begin_node->end_node, match_tags_visitor, errors);
      }
    } break;


    case AST_ERB_UNLESS_NODE: {
      const AST_ERB_UNLESS_NODE_T* erb_unless_node = (const AST_ERB_UNLESS_NODE_T*) node;

      if (erb_unless_node->statements != NULL) {
        match_tags_in_node_array(erb_unless_node->statements, errors);
      }
      if (erb_unless_node->else_clause != NULL) {
        herb_visit_node((AST_NODE_T*) erb_unless_node->else_clause, match_tags_visitor, errors);
      }
      if (erb_unless_node->end_node != NULL) {
        herb_visit_node((AST_NODE_T*) erb_unless_node->end_node, match_tags_visitor, errors);
      }
    } break;



    case AST_ERB_IN_NODE: {
      const AST_ERB_IN_NODE_T* erb_in_node = (const AST_ERB_IN_NODE_T*) node;

      if (erb_in_node->statements != NULL) {
        match_tags_in_node_array(erb_in_node->statements, errors);
      }
    } break;

    default: break;
  }

  return false;
}

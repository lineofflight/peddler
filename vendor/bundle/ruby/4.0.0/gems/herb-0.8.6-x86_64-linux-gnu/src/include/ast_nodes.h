// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/src/include/ast_nodes.h.erb

#ifndef HERB_AST_NODES_H
#define HERB_AST_NODES_H

#include <stdbool.h>
#include <prism.h>

#include "analyzed_ruby.h"
#include "element_source.h"
#include "location.h"
#include "position.h"
#include "token_struct.h"
#include "util/hb_array.h"
#include "util/hb_buffer.h"
#include "util/hb_string.h"

typedef enum {
  AST_DOCUMENT_NODE,
  AST_LITERAL_NODE,
  AST_HTML_OPEN_TAG_NODE,
  AST_HTML_CLOSE_TAG_NODE,
  AST_HTML_ELEMENT_NODE,
  AST_HTML_ATTRIBUTE_VALUE_NODE,
  AST_HTML_ATTRIBUTE_NAME_NODE,
  AST_HTML_ATTRIBUTE_NODE,
  AST_HTML_TEXT_NODE,
  AST_HTML_COMMENT_NODE,
  AST_HTML_DOCTYPE_NODE,
  AST_XML_DECLARATION_NODE,
  AST_CDATA_NODE,
  AST_WHITESPACE_NODE,
  AST_ERB_CONTENT_NODE,
  AST_ERB_END_NODE,
  AST_ERB_ELSE_NODE,
  AST_ERB_IF_NODE,
  AST_ERB_BLOCK_NODE,
  AST_ERB_WHEN_NODE,
  AST_ERB_CASE_NODE,
  AST_ERB_CASE_MATCH_NODE,
  AST_ERB_WHILE_NODE,
  AST_ERB_UNTIL_NODE,
  AST_ERB_FOR_NODE,
  AST_ERB_RESCUE_NODE,
  AST_ERB_ENSURE_NODE,
  AST_ERB_BEGIN_NODE,
  AST_ERB_UNLESS_NODE,
  AST_ERB_YIELD_NODE,
  AST_ERB_IN_NODE,
} ast_node_type_T;

typedef struct AST_NODE_STRUCT {
  ast_node_type_T type;
  location_T location;
  // maybe a range too?
  hb_array_T* errors;
} AST_NODE_T;


typedef struct AST_DOCUMENT_NODE_STRUCT {
  AST_NODE_T base;
  hb_array_T* children;
} AST_DOCUMENT_NODE_T;

typedef struct AST_LITERAL_NODE_STRUCT {
  AST_NODE_T base;
  const char* content;
} AST_LITERAL_NODE_T;

typedef struct AST_HTML_OPEN_TAG_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* tag_name;
  token_T* tag_closing;
  hb_array_T* children;
  bool is_void;
} AST_HTML_OPEN_TAG_NODE_T;

typedef struct AST_HTML_CLOSE_TAG_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* tag_name;
  hb_array_T* children;
  token_T* tag_closing;
} AST_HTML_CLOSE_TAG_NODE_T;

typedef struct AST_HTML_ELEMENT_NODE_STRUCT {
  AST_NODE_T base;
  struct AST_HTML_OPEN_TAG_NODE_STRUCT* open_tag;
  token_T* tag_name;
  hb_array_T* body;
  struct AST_HTML_CLOSE_TAG_NODE_STRUCT* close_tag;
  bool is_void;
  element_source_t source;
} AST_HTML_ELEMENT_NODE_T;

typedef struct AST_HTML_ATTRIBUTE_VALUE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* open_quote;
  hb_array_T* children;
  token_T* close_quote;
  bool quoted;
} AST_HTML_ATTRIBUTE_VALUE_NODE_T;

typedef struct AST_HTML_ATTRIBUTE_NAME_NODE_STRUCT {
  AST_NODE_T base;
  hb_array_T* children;
} AST_HTML_ATTRIBUTE_NAME_NODE_T;

typedef struct AST_HTML_ATTRIBUTE_NODE_STRUCT {
  AST_NODE_T base;
  struct AST_HTML_ATTRIBUTE_NAME_NODE_STRUCT* name;
  token_T* equals;
  struct AST_HTML_ATTRIBUTE_VALUE_NODE_STRUCT* value;
} AST_HTML_ATTRIBUTE_NODE_T;

typedef struct AST_HTML_TEXT_NODE_STRUCT {
  AST_NODE_T base;
  const char* content;
} AST_HTML_TEXT_NODE_T;

typedef struct AST_HTML_COMMENT_NODE_STRUCT {
  AST_NODE_T base;
  token_T* comment_start;
  hb_array_T* children;
  token_T* comment_end;
} AST_HTML_COMMENT_NODE_T;

typedef struct AST_HTML_DOCTYPE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  hb_array_T* children;
  token_T* tag_closing;
} AST_HTML_DOCTYPE_NODE_T;

typedef struct AST_XML_DECLARATION_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  hb_array_T* children;
  token_T* tag_closing;
} AST_XML_DECLARATION_NODE_T;

typedef struct AST_CDATA_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  hb_array_T* children;
  token_T* tag_closing;
} AST_CDATA_NODE_T;

typedef struct AST_WHITESPACE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* value;
} AST_WHITESPACE_NODE_T;

typedef struct AST_ERB_CONTENT_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  analyzed_ruby_T* analyzed_ruby;
  bool parsed;
  bool valid;
} AST_ERB_CONTENT_NODE_T;

typedef struct AST_ERB_END_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
} AST_ERB_END_NODE_T;

typedef struct AST_ERB_ELSE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
} AST_ERB_ELSE_NODE_T;

typedef struct AST_ERB_IF_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
  struct AST_NODE_STRUCT* subsequent;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_IF_NODE_T;

typedef struct AST_ERB_BLOCK_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* body;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_BLOCK_NODE_T;

typedef struct AST_ERB_WHEN_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
} AST_ERB_WHEN_NODE_T;

typedef struct AST_ERB_CASE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* children;
  hb_array_T* conditions;
  struct AST_ERB_ELSE_NODE_STRUCT* else_clause;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_CASE_NODE_T;

typedef struct AST_ERB_CASE_MATCH_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* children;
  hb_array_T* conditions;
  struct AST_ERB_ELSE_NODE_STRUCT* else_clause;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_CASE_MATCH_NODE_T;

typedef struct AST_ERB_WHILE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_WHILE_NODE_T;

typedef struct AST_ERB_UNTIL_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_UNTIL_NODE_T;

typedef struct AST_ERB_FOR_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_FOR_NODE_T;

typedef struct AST_ERB_RESCUE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
  struct AST_ERB_RESCUE_NODE_STRUCT* subsequent;
} AST_ERB_RESCUE_NODE_T;

typedef struct AST_ERB_ENSURE_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
} AST_ERB_ENSURE_NODE_T;

typedef struct AST_ERB_BEGIN_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
  struct AST_ERB_RESCUE_NODE_STRUCT* rescue_clause;
  struct AST_ERB_ELSE_NODE_STRUCT* else_clause;
  struct AST_ERB_ENSURE_NODE_STRUCT* ensure_clause;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_BEGIN_NODE_T;

typedef struct AST_ERB_UNLESS_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
  struct AST_ERB_ELSE_NODE_STRUCT* else_clause;
  struct AST_ERB_END_NODE_STRUCT* end_node;
} AST_ERB_UNLESS_NODE_T;

typedef struct AST_ERB_YIELD_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
} AST_ERB_YIELD_NODE_T;

typedef struct AST_ERB_IN_NODE_STRUCT {
  AST_NODE_T base;
  token_T* tag_opening;
  token_T* content;
  token_T* tag_closing;
  hb_array_T* statements;
} AST_ERB_IN_NODE_T;

AST_DOCUMENT_NODE_T* ast_document_node_init(hb_array_T* children, position_T start_position, position_T end_position, hb_array_T* errors);
AST_LITERAL_NODE_T* ast_literal_node_init(const char* content, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_OPEN_TAG_NODE_T* ast_html_open_tag_node_init(token_T* tag_opening, token_T* tag_name, token_T* tag_closing, hb_array_T* children, bool is_void, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_CLOSE_TAG_NODE_T* ast_html_close_tag_node_init(token_T* tag_opening, token_T* tag_name, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_ELEMENT_NODE_T* ast_html_element_node_init(struct AST_HTML_OPEN_TAG_NODE_STRUCT* open_tag, token_T* tag_name, hb_array_T* body, struct AST_HTML_CLOSE_TAG_NODE_STRUCT* close_tag, bool is_void, element_source_t source, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_ATTRIBUTE_VALUE_NODE_T* ast_html_attribute_value_node_init(token_T* open_quote, hb_array_T* children, token_T* close_quote, bool quoted, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_ATTRIBUTE_NAME_NODE_T* ast_html_attribute_name_node_init(hb_array_T* children, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_ATTRIBUTE_NODE_T* ast_html_attribute_node_init(struct AST_HTML_ATTRIBUTE_NAME_NODE_STRUCT* name, token_T* equals, struct AST_HTML_ATTRIBUTE_VALUE_NODE_STRUCT* value, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_TEXT_NODE_T* ast_html_text_node_init(const char* content, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_COMMENT_NODE_T* ast_html_comment_node_init(token_T* comment_start, hb_array_T* children, token_T* comment_end, position_T start_position, position_T end_position, hb_array_T* errors);
AST_HTML_DOCTYPE_NODE_T* ast_html_doctype_node_init(token_T* tag_opening, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors);
AST_XML_DECLARATION_NODE_T* ast_xml_declaration_node_init(token_T* tag_opening, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors);
AST_CDATA_NODE_T* ast_cdata_node_init(token_T* tag_opening, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors);
AST_WHITESPACE_NODE_T* ast_whitespace_node_init(token_T* value, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_CONTENT_NODE_T* ast_erb_content_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, analyzed_ruby_T* analyzed_ruby, bool parsed, bool valid, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_END_NODE_T* ast_erb_end_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_ELSE_NODE_T* ast_erb_else_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_IF_NODE_T* ast_erb_if_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_NODE_STRUCT* subsequent, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_BLOCK_NODE_T* ast_erb_block_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* body, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_WHEN_NODE_T* ast_erb_when_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_CASE_NODE_T* ast_erb_case_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* children, hb_array_T* conditions, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_CASE_MATCH_NODE_T* ast_erb_case_match_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* children, hb_array_T* conditions, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_WHILE_NODE_T* ast_erb_while_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_UNTIL_NODE_T* ast_erb_until_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_FOR_NODE_T* ast_erb_for_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_RESCUE_NODE_T* ast_erb_rescue_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_RESCUE_NODE_STRUCT* subsequent, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_ENSURE_NODE_T* ast_erb_ensure_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_BEGIN_NODE_T* ast_erb_begin_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_RESCUE_NODE_STRUCT* rescue_clause, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_ENSURE_NODE_STRUCT* ensure_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_UNLESS_NODE_T* ast_erb_unless_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_YIELD_NODE_T* ast_erb_yield_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors);
AST_ERB_IN_NODE_T* ast_erb_in_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors);

hb_string_T ast_node_type_to_string(AST_NODE_T* node);
hb_string_T ast_node_human_type(AST_NODE_T* node);

#endif

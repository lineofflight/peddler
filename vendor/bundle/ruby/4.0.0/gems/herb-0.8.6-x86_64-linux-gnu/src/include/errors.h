// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/src/include/errors.h.erb

#ifndef HERB_ERRORS_H
#define HERB_ERRORS_H

#include "errors.h"
#include "location.h"
#include "position.h"
#include "token.h"
#include "util/hb_array.h"
#include "util/hb_buffer.h"

typedef enum {
  UNEXPECTED_ERROR,
  UNEXPECTED_TOKEN_ERROR,
  MISSING_OPENING_TAG_ERROR,
  MISSING_CLOSING_TAG_ERROR,
  TAG_NAMES_MISMATCH_ERROR,
  QUOTES_MISMATCH_ERROR,
  VOID_ELEMENT_CLOSING_TAG_ERROR,
  UNCLOSED_ELEMENT_ERROR,
  RUBY_PARSE_ERROR,
  ERB_CONTROL_FLOW_SCOPE_ERROR,
  MISSINGERB_END_TAG_ERROR,
  ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR,
} error_type_T;

typedef struct ERROR_STRUCT {
  error_type_T type;
  location_T location;
  char* message;
} ERROR_T;


typedef struct {
  ERROR_T base;
  const char* description;
  const char* expected;
  const char* found;
} UNEXPECTED_ERROR_T;

typedef struct {
  ERROR_T base;
  token_type_T expected_type;
  token_T* found;
} UNEXPECTED_TOKEN_ERROR_T;

typedef struct {
  ERROR_T base;
  token_T* closing_tag;
} MISSING_OPENING_TAG_ERROR_T;

typedef struct {
  ERROR_T base;
  token_T* opening_tag;
} MISSING_CLOSING_TAG_ERROR_T;

typedef struct {
  ERROR_T base;
  token_T* opening_tag;
  token_T* closing_tag;
} TAG_NAMES_MISMATCH_ERROR_T;

typedef struct {
  ERROR_T base;
  token_T* opening_quote;
  token_T* closing_quote;
} QUOTES_MISMATCH_ERROR_T;

typedef struct {
  ERROR_T base;
  token_T* tag_name;
  const char* expected;
  const char* found;
} VOID_ELEMENT_CLOSING_TAG_ERROR_T;

typedef struct {
  ERROR_T base;
  token_T* opening_tag;
} UNCLOSED_ELEMENT_ERROR_T;

typedef struct {
  ERROR_T base;
  const char* error_message;
  const char* diagnostic_id;
  const char* level;
} RUBY_PARSE_ERROR_T;

typedef struct {
  ERROR_T base;
  const char* keyword;
} ERB_CONTROL_FLOW_SCOPE_ERROR_T;

typedef struct {
  ERROR_T base;
  const char* keyword;
} MISSINGERB_END_TAG_ERROR_T;

typedef struct {
  ERROR_T base;
  /* no additional fields */
} ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T;

UNEXPECTED_ERROR_T* unexpected_error_init(const char* description, const char* expected, const char* found, position_T start, position_T end);
void append_unexpected_error(const char* description, const char* expected, const char* found, position_T start, position_T end, hb_array_T* errors);
UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error_init(token_type_T expected_type, token_T* found, position_T start, position_T end);
void append_unexpected_token_error(token_type_T expected_type, token_T* found, position_T start, position_T end, hb_array_T* errors);
MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error_init(token_T* closing_tag, position_T start, position_T end);
void append_missing_opening_tag_error(token_T* closing_tag, position_T start, position_T end, hb_array_T* errors);
MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error_init(token_T* opening_tag, position_T start, position_T end);
void append_missing_closing_tag_error(token_T* opening_tag, position_T start, position_T end, hb_array_T* errors);
TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error_init(token_T* opening_tag, token_T* closing_tag, position_T start, position_T end);
void append_tag_names_mismatch_error(token_T* opening_tag, token_T* closing_tag, position_T start, position_T end, hb_array_T* errors);
QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error_init(token_T* opening_quote, token_T* closing_quote, position_T start, position_T end);
void append_quotes_mismatch_error(token_T* opening_quote, token_T* closing_quote, position_T start, position_T end, hb_array_T* errors);
VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error_init(token_T* tag_name, const char* expected, const char* found, position_T start, position_T end);
void append_void_element_closing_tag_error(token_T* tag_name, const char* expected, const char* found, position_T start, position_T end, hb_array_T* errors);
UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error_init(token_T* opening_tag, position_T start, position_T end);
void append_unclosed_element_error(token_T* opening_tag, position_T start, position_T end, hb_array_T* errors);
RUBY_PARSE_ERROR_T* ruby_parse_error_init(const char* error_message, const char* diagnostic_id, const char* level, position_T start, position_T end);
void append_ruby_parse_error(const char* error_message, const char* diagnostic_id, const char* level, position_T start, position_T end, hb_array_T* errors);
ERB_CONTROL_FLOW_SCOPE_ERROR_T* erb_control_flow_scope_error_init(const char* keyword, position_T start, position_T end);
void append_erb_control_flow_scope_error(const char* keyword, position_T start, position_T end, hb_array_T* errors);
MISSINGERB_END_TAG_ERROR_T* missingerb_end_tag_error_init(const char* keyword, position_T start, position_T end);
void append_missingerb_end_tag_error(const char* keyword, position_T start, position_T end, hb_array_T* errors);
ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T* erb_multiple_blocks_in_tag_error_init(position_T start, position_T end);
void append_erb_multiple_blocks_in_tag_error(position_T start, position_T end, hb_array_T* errors);

void error_init(ERROR_T* error, error_type_T type, position_T start, position_T end);

size_t error_sizeof(void);
error_type_T error_type(ERROR_T* error);

char* error_message(ERROR_T* error);

const char* error_type_to_string(ERROR_T* error);
const char* error_human_type(ERROR_T* error);

void error_free(ERROR_T* error);

void error_pretty_print(ERROR_T* error, size_t indent, size_t relative_indent, hb_buffer_T* buffer);

void error_pretty_print_array(
  const char* name, hb_array_T* array, size_t indent, size_t relative_indent, bool last_property,
  hb_buffer_T* buffer
);

#endif

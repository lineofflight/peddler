// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/src/errors.c.erb

#include "include/errors.h"
#include "include/location.h"
#include "include/position.h"
#include "include/pretty_print.h"
#include "include/token.h"
#include "include/util.h"
#include "include/util/hb_array.h"

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define ERROR_MESSAGES_TRUNCATED_LENGTH 128

size_t error_sizeof(void) {
  return sizeof(struct ERROR_STRUCT);
}

void error_init(ERROR_T* error, const error_type_T type, position_T start, position_T end) {
  if (!error) { return; }

  error->type = type;
  error->location.start = start;
  error->location.end = end;
}

UNEXPECTED_ERROR_T* unexpected_error_init(const char* description, const char* expected, const char* found, position_T start, position_T end) {
  UNEXPECTED_ERROR_T* unexpected_error = malloc(sizeof(UNEXPECTED_ERROR_T));

  error_init(&unexpected_error->base, UNEXPECTED_ERROR, start, end);

  const char* message_template = "%s. Expected: `%s`, found: `%s`.";

  size_t message_size = 417;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, description, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, expected, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_2, found, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      truncated_argument_2
    );

    unexpected_error->base.message = herb_strdup(message);
    free(message);
  } else {
    unexpected_error->base.message = herb_strdup("%s. Expected: `%s`, found: `%s`.");
  }

  unexpected_error->description = herb_strdup(description);
  unexpected_error->expected = herb_strdup(expected);
  unexpected_error->found = herb_strdup(found);
  return unexpected_error;
}

void append_unexpected_error(const char* description, const char* expected, const char* found, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, unexpected_error_init(description, expected, found, start, end));
}

UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error_init(token_type_T expected_type, token_T* found, position_T start, position_T end) {
  UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error = malloc(sizeof(UNEXPECTED_TOKEN_ERROR_T));

  error_init(&unexpected_token_error->base, UNEXPECTED_TOKEN_ERROR, start, end);

  const char* message_template = "Found `%s` when expecting `%s` at (%u:%u).";

  size_t message_size = 319;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, token_type_to_string(found->type), ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, token_type_to_string(expected_type), ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      found->location.start.line,
      found->location.start.column
    );

    unexpected_token_error->base.message = herb_strdup(message);
    free(message);
  } else {
    unexpected_token_error->base.message = herb_strdup("Found `%s` when expecting `%s` at (%u:%u).");
  }

  unexpected_token_error->expected_type = expected_type;
  unexpected_token_error->found = token_copy(found);
  return unexpected_token_error;
}

void append_unexpected_token_error(token_type_T expected_type, token_T* found, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, unexpected_token_error_init(expected_type, found, start, end));
}

MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error_init(token_T* closing_tag, position_T start, position_T end) {
  MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error = malloc(sizeof(MISSING_OPENING_TAG_ERROR_T));

  error_init(&missing_opening_tag_error->base, MISSING_OPENING_TAG_ERROR, start, end);

  const char* message_template = "Found closing tag `</%s>` at (%u:%u) without a matching opening tag in the same scope.";

  size_t message_size = 235;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, closing_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      closing_tag->location.start.line,
      closing_tag->location.start.column
    );

    missing_opening_tag_error->base.message = herb_strdup(message);
    free(message);
  } else {
    missing_opening_tag_error->base.message = herb_strdup("Found closing tag `</%s>` at (%u:%u) without a matching opening tag in the same scope.");
  }

  missing_opening_tag_error->closing_tag = token_copy(closing_tag);
  return missing_opening_tag_error;
}

void append_missing_opening_tag_error(token_T* closing_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, missing_opening_tag_error_init(closing_tag, start, end));
}

MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error_init(token_T* opening_tag, position_T start, position_T end) {
  MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error = malloc(sizeof(MISSING_CLOSING_TAG_ERROR_T));

  error_init(&missing_closing_tag_error->base, MISSING_CLOSING_TAG_ERROR, start, end);

  const char* message_template = "Opening tag `<%s>` at (%u:%u) doesn't have a matching closing tag `</%s>` in the same scope.";

  size_t message_size = 369;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_3, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      opening_tag->location.start.line,
      opening_tag->location.start.column,
      truncated_argument_3
    );

    missing_closing_tag_error->base.message = herb_strdup(message);
    free(message);
  } else {
    missing_closing_tag_error->base.message = herb_strdup("Opening tag `<%s>` at (%u:%u) doesn't have a matching closing tag `</%s>` in the same scope.");
  }

  missing_closing_tag_error->opening_tag = token_copy(opening_tag);
  return missing_closing_tag_error;
}

void append_missing_closing_tag_error(token_T* opening_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, missing_closing_tag_error_init(opening_tag, start, end));
}

TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error_init(token_T* opening_tag, token_T* closing_tag, position_T start, position_T end) {
  TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error = malloc(sizeof(TAG_NAMES_MISMATCH_ERROR_T));

  error_init(&tag_names_mismatch_error->base, TAG_NAMES_MISMATCH_ERROR, start, end);

  const char* message_template = "Opening tag `<%s>` at (%u:%u) closed with `</%s>` at (%u:%u).";

  size_t message_size = 358;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_3, closing_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      opening_tag->location.start.line,
      opening_tag->location.start.column,
      truncated_argument_3,
      closing_tag->location.start.line,
      closing_tag->location.start.column
    );

    tag_names_mismatch_error->base.message = herb_strdup(message);
    free(message);
  } else {
    tag_names_mismatch_error->base.message = herb_strdup("Opening tag `<%s>` at (%u:%u) closed with `</%s>` at (%u:%u).");
  }

  tag_names_mismatch_error->opening_tag = token_copy(opening_tag);
  tag_names_mismatch_error->closing_tag = token_copy(closing_tag);
  return tag_names_mismatch_error;
}

void append_tag_names_mismatch_error(token_T* opening_tag, token_T* closing_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, tag_names_mismatch_error_init(opening_tag, closing_tag, start, end));
}

QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error_init(token_T* opening_quote, token_T* closing_quote, position_T start, position_T end) {
  QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error = malloc(sizeof(QUOTES_MISMATCH_ERROR_T));

  error_init(&quotes_mismatch_error->base, QUOTES_MISMATCH_ERROR, start, end);

  const char* message_template = "String opened with %s but closed with %s at (%u:%u).";

  size_t message_size = 329;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_quote->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, closing_quote->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      closing_quote->location.start.line,
      closing_quote->location.start.column
    );

    quotes_mismatch_error->base.message = herb_strdup(message);
    free(message);
  } else {
    quotes_mismatch_error->base.message = herb_strdup("String opened with %s but closed with %s at (%u:%u).");
  }

  quotes_mismatch_error->opening_quote = token_copy(opening_quote);
  quotes_mismatch_error->closing_quote = token_copy(closing_quote);
  return quotes_mismatch_error;
}

void append_quotes_mismatch_error(token_T* opening_quote, token_T* closing_quote, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, quotes_mismatch_error_init(opening_quote, closing_quote, start, end));
}

VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error_init(token_T* tag_name, const char* expected, const char* found, position_T start, position_T end) {
  VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error = malloc(sizeof(VOID_ELEMENT_CLOSING_TAG_ERROR_T));

  error_init(&void_element_closing_tag_error->base, VOID_ELEMENT_CLOSING_TAG_ERROR, start, end);

  const char* message_template = "`%s` is a void element and should not be used as a closing tag. Use `<%s>` or `<%s />` instead of `</%s>`.";

  size_t message_size = 619;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_2, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_2[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_3, tag_name->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_3[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1,
      truncated_argument_2,
      truncated_argument_3
    );

    void_element_closing_tag_error->base.message = herb_strdup(message);
    free(message);
  } else {
    void_element_closing_tag_error->base.message = herb_strdup("`%s` is a void element and should not be used as a closing tag. Use `<%s>` or `<%s />` instead of `</%s>`.");
  }

  void_element_closing_tag_error->tag_name = token_copy(tag_name);
  void_element_closing_tag_error->expected = herb_strdup(expected);
  void_element_closing_tag_error->found = herb_strdup(found);
  return void_element_closing_tag_error;
}

void append_void_element_closing_tag_error(token_T* tag_name, const char* expected, const char* found, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, void_element_closing_tag_error_init(tag_name, expected, found, start, end));
}

UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error_init(token_T* opening_tag, position_T start, position_T end) {
  UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error = malloc(sizeof(UNCLOSED_ELEMENT_ERROR_T));

  error_init(&unclosed_element_error->base, UNCLOSED_ELEMENT_ERROR, start, end);

  const char* message_template = "Tag `<%s>` opened at (%u:%u) was never closed before the end of document.";

  size_t message_size = 222;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, opening_tag->value, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      opening_tag->location.start.line,
      opening_tag->location.start.column
    );

    unclosed_element_error->base.message = herb_strdup(message);
    free(message);
  } else {
    unclosed_element_error->base.message = herb_strdup("Tag `<%s>` opened at (%u:%u) was never closed before the end of document.");
  }

  unclosed_element_error->opening_tag = token_copy(opening_tag);
  return unclosed_element_error;
}

void append_unclosed_element_error(token_T* opening_tag, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, unclosed_element_error_init(opening_tag, start, end));
}

RUBY_PARSE_ERROR_T* ruby_parse_error_init(const char* error_message, const char* diagnostic_id, const char* level, position_T start, position_T end) {
  RUBY_PARSE_ERROR_T* ruby_parse_error = malloc(sizeof(RUBY_PARSE_ERROR_T));

  error_init(&ruby_parse_error->base, RUBY_PARSE_ERROR, start, end);

  const char* message_template = "%s: %s";

  size_t message_size = 263;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, diagnostic_id, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    char truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_1, error_message, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_1[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0,
      truncated_argument_1
    );

    ruby_parse_error->base.message = herb_strdup(message);
    free(message);
  } else {
    ruby_parse_error->base.message = herb_strdup("%s: %s");
  }

  ruby_parse_error->error_message = herb_strdup(error_message);
  ruby_parse_error->diagnostic_id = herb_strdup(diagnostic_id);
  ruby_parse_error->level = herb_strdup(level);
  return ruby_parse_error;
}

void append_ruby_parse_error(const char* error_message, const char* diagnostic_id, const char* level, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, ruby_parse_error_init(error_message, diagnostic_id, level, start, end));
}

ERB_CONTROL_FLOW_SCOPE_ERROR_T* erb_control_flow_scope_error_init(const char* keyword, position_T start, position_T end) {
  ERB_CONTROL_FLOW_SCOPE_ERROR_T* erb_control_flow_scope_error = malloc(sizeof(ERB_CONTROL_FLOW_SCOPE_ERROR_T));

  error_init(&erb_control_flow_scope_error->base, ERB_CONTROL_FLOW_SCOPE_ERROR, start, end);

  const char* message_template = "%s appears outside its control flow block. Keep ERB control flow statements together within the same HTML scope (tag, attribute, or content).";

  size_t message_size = 270;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, keyword, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0
    );

    erb_control_flow_scope_error->base.message = herb_strdup(message);
    free(message);
  } else {
    erb_control_flow_scope_error->base.message = herb_strdup("%s appears outside its control flow block. Keep ERB control flow statements together within the same HTML scope (tag, attribute, or content).");
  }

  erb_control_flow_scope_error->keyword = herb_strdup(keyword);
  return erb_control_flow_scope_error;
}

void append_erb_control_flow_scope_error(const char* keyword, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, erb_control_flow_scope_error_init(keyword, start, end));
}

MISSINGERB_END_TAG_ERROR_T* missingerb_end_tag_error_init(const char* keyword, position_T start, position_T end) {
  MISSINGERB_END_TAG_ERROR_T* missingerb_end_tag_error = malloc(sizeof(MISSINGERB_END_TAG_ERROR_T));

  error_init(&missingerb_end_tag_error->base, MISSINGERB_END_TAG_ERROR, start, end);

  const char* message_template = "%s started here but never closed with an end tag. The end tag may be in a different scope.";

  size_t message_size = 219;
  char* message = (char*) malloc(message_size);

  if (message) {
    char truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH + 1];
    strncpy(truncated_argument_0, keyword, ERROR_MESSAGES_TRUNCATED_LENGTH);
    truncated_argument_0[ERROR_MESSAGES_TRUNCATED_LENGTH] = '\0';

    snprintf(
      message,
      message_size,
      message_template,
      truncated_argument_0
    );

    missingerb_end_tag_error->base.message = herb_strdup(message);
    free(message);
  } else {
    missingerb_end_tag_error->base.message = herb_strdup("%s started here but never closed with an end tag. The end tag may be in a different scope.");
  }

  missingerb_end_tag_error->keyword = herb_strdup(keyword);
  return missingerb_end_tag_error;
}

void append_missingerb_end_tag_error(const char* keyword, position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, missingerb_end_tag_error_init(keyword, start, end));
}

ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T* erb_multiple_blocks_in_tag_error_init(position_T start, position_T end) {
  ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T* erb_multiple_blocks_in_tag_error = malloc(sizeof(ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T));

  error_init(&erb_multiple_blocks_in_tag_error->base, ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR, start, end);

  erb_multiple_blocks_in_tag_error->base.message = herb_strdup("Multiple unclosed control flow blocks in a single ERB tag. Split each block into its own ERB tag, or close all blocks within the same tag.");

  return erb_multiple_blocks_in_tag_error;
}

void append_erb_multiple_blocks_in_tag_error(position_T start, position_T end, hb_array_T* errors) {
  hb_array_append(errors, erb_multiple_blocks_in_tag_error_init(start, end));
}

const char* error_type_to_string(ERROR_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return "UNEXPECTED_ERROR";
    case UNEXPECTED_TOKEN_ERROR: return "UNEXPECTED_TOKEN_ERROR";
    case MISSING_OPENING_TAG_ERROR: return "MISSING_OPENING_TAG_ERROR";
    case MISSING_CLOSING_TAG_ERROR: return "MISSING_CLOSING_TAG_ERROR";
    case TAG_NAMES_MISMATCH_ERROR: return "TAG_NAMES_MISMATCH_ERROR";
    case QUOTES_MISMATCH_ERROR: return "QUOTES_MISMATCH_ERROR";
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return "VOID_ELEMENT_CLOSING_TAG_ERROR";
    case UNCLOSED_ELEMENT_ERROR: return "UNCLOSED_ELEMENT_ERROR";
    case RUBY_PARSE_ERROR: return "RUBY_PARSE_ERROR";
    case ERB_CONTROL_FLOW_SCOPE_ERROR: return "ERB_CONTROL_FLOW_SCOPE_ERROR";
    case MISSINGERB_END_TAG_ERROR: return "MISSINGERB_END_TAG_ERROR";
    case ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR: return "ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR";
  }

  return "Unknown error_type_T";
}

const char* error_human_type(ERROR_T* error) {
  switch (error->type) {
    case UNEXPECTED_ERROR: return "UnexpectedError";
    case UNEXPECTED_TOKEN_ERROR: return "UnexpectedTokenError";
    case MISSING_OPENING_TAG_ERROR: return "MissingOpeningTagError";
    case MISSING_CLOSING_TAG_ERROR: return "MissingClosingTagError";
    case TAG_NAMES_MISMATCH_ERROR: return "TagNamesMismatchError";
    case QUOTES_MISMATCH_ERROR: return "QuotesMismatchError";
    case VOID_ELEMENT_CLOSING_TAG_ERROR: return "VoidElementClosingTagError";
    case UNCLOSED_ELEMENT_ERROR: return "UnclosedElementError";
    case RUBY_PARSE_ERROR: return "RubyParseError";
    case ERB_CONTROL_FLOW_SCOPE_ERROR: return "ERBControlFlowScopeError";
    case MISSINGERB_END_TAG_ERROR: return "MissingERBEndTagError";
    case ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR: return "ERBMultipleBlocksInTagError";
  }

  return "Unknown error_type_T";
}

void error_free_base_error(ERROR_T* error) {
  if (error == NULL) { return; }

  if (error->message != NULL) { free(error->message); }

  free(error);
}

static void error_free_unexpected_error(UNEXPECTED_ERROR_T* unexpected_error) {
  if (unexpected_error->description != NULL) { free((char*) unexpected_error->description); }
  if (unexpected_error->expected != NULL) { free((char*) unexpected_error->expected); }
  if (unexpected_error->found != NULL) { free((char*) unexpected_error->found); }

  error_free_base_error(&unexpected_error->base);
}

static void error_free_unexpected_token_error(UNEXPECTED_TOKEN_ERROR_T* unexpected_token_error) {
  // token_type_T is part of struct
  if (unexpected_token_error->found != NULL) { token_free(unexpected_token_error->found); }

  error_free_base_error(&unexpected_token_error->base);
}

static void error_free_missing_opening_tag_error(MISSING_OPENING_TAG_ERROR_T* missing_opening_tag_error) {
  if (missing_opening_tag_error->closing_tag != NULL) { token_free(missing_opening_tag_error->closing_tag); }

  error_free_base_error(&missing_opening_tag_error->base);
}

static void error_free_missing_closing_tag_error(MISSING_CLOSING_TAG_ERROR_T* missing_closing_tag_error) {
  if (missing_closing_tag_error->opening_tag != NULL) { token_free(missing_closing_tag_error->opening_tag); }

  error_free_base_error(&missing_closing_tag_error->base);
}

static void error_free_tag_names_mismatch_error(TAG_NAMES_MISMATCH_ERROR_T* tag_names_mismatch_error) {
  if (tag_names_mismatch_error->opening_tag != NULL) { token_free(tag_names_mismatch_error->opening_tag); }
  if (tag_names_mismatch_error->closing_tag != NULL) { token_free(tag_names_mismatch_error->closing_tag); }

  error_free_base_error(&tag_names_mismatch_error->base);
}

static void error_free_quotes_mismatch_error(QUOTES_MISMATCH_ERROR_T* quotes_mismatch_error) {
  if (quotes_mismatch_error->opening_quote != NULL) { token_free(quotes_mismatch_error->opening_quote); }
  if (quotes_mismatch_error->closing_quote != NULL) { token_free(quotes_mismatch_error->closing_quote); }

  error_free_base_error(&quotes_mismatch_error->base);
}

static void error_free_void_element_closing_tag_error(VOID_ELEMENT_CLOSING_TAG_ERROR_T* void_element_closing_tag_error) {
  if (void_element_closing_tag_error->tag_name != NULL) { token_free(void_element_closing_tag_error->tag_name); }
  if (void_element_closing_tag_error->expected != NULL) { free((char*) void_element_closing_tag_error->expected); }
  if (void_element_closing_tag_error->found != NULL) { free((char*) void_element_closing_tag_error->found); }

  error_free_base_error(&void_element_closing_tag_error->base);
}

static void error_free_unclosed_element_error(UNCLOSED_ELEMENT_ERROR_T* unclosed_element_error) {
  if (unclosed_element_error->opening_tag != NULL) { token_free(unclosed_element_error->opening_tag); }

  error_free_base_error(&unclosed_element_error->base);
}

static void error_free_ruby_parse_error(RUBY_PARSE_ERROR_T* ruby_parse_error) {
  if (ruby_parse_error->error_message != NULL) { free((char*) ruby_parse_error->error_message); }
  if (ruby_parse_error->diagnostic_id != NULL) { free((char*) ruby_parse_error->diagnostic_id); }
  if (ruby_parse_error->level != NULL) { free((char*) ruby_parse_error->level); }

  error_free_base_error(&ruby_parse_error->base);
}

static void error_free_erb_control_flow_scope_error(ERB_CONTROL_FLOW_SCOPE_ERROR_T* erb_control_flow_scope_error) {
  if (erb_control_flow_scope_error->keyword != NULL) { free((char*) erb_control_flow_scope_error->keyword); }

  error_free_base_error(&erb_control_flow_scope_error->base);
}

static void error_free_missingerb_end_tag_error(MISSINGERB_END_TAG_ERROR_T* missingerb_end_tag_error) {
  if (missingerb_end_tag_error->keyword != NULL) { free((char*) missingerb_end_tag_error->keyword); }

  error_free_base_error(&missingerb_end_tag_error->base);
}

static void error_free_erb_multiple_blocks_in_tag_error(ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T* erb_multiple_blocks_in_tag_error) {
  /* no ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T specific fields to free up */

  error_free_base_error(&erb_multiple_blocks_in_tag_error->base);
}

void error_free(ERROR_T* error) {
  if (!error) { return; }

  switch (error->type) {
    case UNEXPECTED_ERROR: error_free_unexpected_error((UNEXPECTED_ERROR_T*) error); break;
    case UNEXPECTED_TOKEN_ERROR: error_free_unexpected_token_error((UNEXPECTED_TOKEN_ERROR_T*) error); break;
    case MISSING_OPENING_TAG_ERROR: error_free_missing_opening_tag_error((MISSING_OPENING_TAG_ERROR_T*) error); break;
    case MISSING_CLOSING_TAG_ERROR: error_free_missing_closing_tag_error((MISSING_CLOSING_TAG_ERROR_T*) error); break;
    case TAG_NAMES_MISMATCH_ERROR: error_free_tag_names_mismatch_error((TAG_NAMES_MISMATCH_ERROR_T*) error); break;
    case QUOTES_MISMATCH_ERROR: error_free_quotes_mismatch_error((QUOTES_MISMATCH_ERROR_T*) error); break;
    case VOID_ELEMENT_CLOSING_TAG_ERROR: error_free_void_element_closing_tag_error((VOID_ELEMENT_CLOSING_TAG_ERROR_T*) error); break;
    case UNCLOSED_ELEMENT_ERROR: error_free_unclosed_element_error((UNCLOSED_ELEMENT_ERROR_T*) error); break;
    case RUBY_PARSE_ERROR: error_free_ruby_parse_error((RUBY_PARSE_ERROR_T*) error); break;
    case ERB_CONTROL_FLOW_SCOPE_ERROR: error_free_erb_control_flow_scope_error((ERB_CONTROL_FLOW_SCOPE_ERROR_T*) error); break;
    case MISSINGERB_END_TAG_ERROR: error_free_missingerb_end_tag_error((MISSINGERB_END_TAG_ERROR_T*) error); break;
    case ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR: error_free_erb_multiple_blocks_in_tag_error((ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T*) error); break;
  }
}

void error_pretty_print_array(
  const char* name, hb_array_T* array, const size_t indent, const size_t relative_indent, const bool last_property,
  hb_buffer_T* buffer
) {
  if (array == NULL) {
    pretty_print_property(hb_string(name), hb_string("∅"), indent, relative_indent, last_property, buffer);

    return;
  }

  if (array->size == 0) {
    pretty_print_property(hb_string(name), hb_string("[]"), indent, relative_indent, last_property, buffer);

    return;
  }

  pretty_print_label(hb_string(name), indent, relative_indent, last_property, buffer);

  hb_buffer_append(buffer, "(");

  char count[16];
  sprintf(count, "%zu", array->size);
  hb_buffer_append(buffer, count);
  hb_buffer_append(buffer, ")\n");

  if (indent < 20) {
    for (size_t i = 0; i < array->size; i++) {
      ERROR_T* child = hb_array_get(array, i);
      pretty_print_indent(buffer, indent);
      pretty_print_indent(buffer, relative_indent + 1);

      if (i == array->size - 1) {
        hb_buffer_append(buffer, "└── ");
      } else {
        hb_buffer_append(buffer, "├── ");
      }

      error_pretty_print(child, indent + 1, relative_indent + 1, buffer);

      if (i != array->size - 1) { pretty_print_newline(indent + 1, relative_indent, buffer); }
    }
  }
}

static void error_pretty_print_unexpected_error(UNEXPECTED_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("description"), hb_string(error->description), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("expected"), hb_string(error->expected), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("found"), hb_string(error->found), indent, relative_indent, true, buffer);
}

static void error_pretty_print_unexpected_token_error(UNEXPECTED_TOKEN_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_property(hb_string(token_type_to_string(error->expected_type)), hb_string("expected_type"), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->found, hb_string("found"), indent, relative_indent, true, buffer);
}

static void error_pretty_print_missing_opening_tag_error(MISSING_OPENING_TAG_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->closing_tag, hb_string("closing_tag"), indent, relative_indent, true, buffer);
}

static void error_pretty_print_missing_closing_tag_error(MISSING_CLOSING_TAG_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->opening_tag, hb_string("opening_tag"), indent, relative_indent, true, buffer);
}

static void error_pretty_print_tag_names_mismatch_error(TAG_NAMES_MISMATCH_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->opening_tag, hb_string("opening_tag"), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->closing_tag, hb_string("closing_tag"), indent, relative_indent, true, buffer);
}

static void error_pretty_print_quotes_mismatch_error(QUOTES_MISMATCH_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->opening_quote, hb_string("opening_quote"), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->closing_quote, hb_string("closing_quote"), indent, relative_indent, true, buffer);
}

static void error_pretty_print_void_element_closing_tag_error(VOID_ELEMENT_CLOSING_TAG_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->tag_name, hb_string("tag_name"), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("expected"), hb_string(error->expected), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("found"), hb_string(error->found), indent, relative_indent, true, buffer);
}

static void error_pretty_print_unclosed_element_error(UNCLOSED_ELEMENT_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_token_property(error->opening_tag, hb_string("opening_tag"), indent, relative_indent, true, buffer);
}

static void error_pretty_print_ruby_parse_error(RUBY_PARSE_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("error_message"), hb_string(error->error_message), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("diagnostic_id"), hb_string(error->diagnostic_id), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("level"), hb_string(error->level), indent, relative_indent, true, buffer);
}

static void error_pretty_print_erb_control_flow_scope_error(ERB_CONTROL_FLOW_SCOPE_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("keyword"), hb_string(error->keyword), indent, relative_indent, true, buffer);
}

static void error_pretty_print_missingerb_end_tag_error(MISSINGERB_END_TAG_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, false, buffer);
  pretty_print_quoted_property(hb_string("keyword"), hb_string(error->keyword), indent, relative_indent, true, buffer);
}

static void error_pretty_print_erb_multiple_blocks_in_tag_error(ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  hb_buffer_append(buffer, "@ ");
  hb_buffer_append(buffer, error_human_type((ERROR_T*) error));
  hb_buffer_append(buffer, " ");

  pretty_print_location(error->base.location, buffer);
  hb_buffer_append(buffer, "\n");

  pretty_print_quoted_property(hb_string("message"), hb_string(error->base.message), indent, relative_indent, true, buffer);
}

void error_pretty_print(ERROR_T* error, const size_t indent, const size_t relative_indent, hb_buffer_T* buffer) {
  if (!error) { return; }

  switch (error->type) {
    case UNEXPECTED_ERROR: error_pretty_print_unexpected_error((UNEXPECTED_ERROR_T*) error, indent, relative_indent, buffer); break;
    case UNEXPECTED_TOKEN_ERROR: error_pretty_print_unexpected_token_error((UNEXPECTED_TOKEN_ERROR_T*) error, indent, relative_indent, buffer); break;
    case MISSING_OPENING_TAG_ERROR: error_pretty_print_missing_opening_tag_error((MISSING_OPENING_TAG_ERROR_T*) error, indent, relative_indent, buffer); break;
    case MISSING_CLOSING_TAG_ERROR: error_pretty_print_missing_closing_tag_error((MISSING_CLOSING_TAG_ERROR_T*) error, indent, relative_indent, buffer); break;
    case TAG_NAMES_MISMATCH_ERROR: error_pretty_print_tag_names_mismatch_error((TAG_NAMES_MISMATCH_ERROR_T*) error, indent, relative_indent, buffer); break;
    case QUOTES_MISMATCH_ERROR: error_pretty_print_quotes_mismatch_error((QUOTES_MISMATCH_ERROR_T*) error, indent, relative_indent, buffer); break;
    case VOID_ELEMENT_CLOSING_TAG_ERROR: error_pretty_print_void_element_closing_tag_error((VOID_ELEMENT_CLOSING_TAG_ERROR_T*) error, indent, relative_indent, buffer); break;
    case UNCLOSED_ELEMENT_ERROR: error_pretty_print_unclosed_element_error((UNCLOSED_ELEMENT_ERROR_T*) error, indent, relative_indent, buffer); break;
    case RUBY_PARSE_ERROR: error_pretty_print_ruby_parse_error((RUBY_PARSE_ERROR_T*) error, indent, relative_indent, buffer); break;
    case ERB_CONTROL_FLOW_SCOPE_ERROR: error_pretty_print_erb_control_flow_scope_error((ERB_CONTROL_FLOW_SCOPE_ERROR_T*) error, indent, relative_indent, buffer); break;
    case MISSINGERB_END_TAG_ERROR: error_pretty_print_missingerb_end_tag_error((MISSINGERB_END_TAG_ERROR_T*) error, indent, relative_indent, buffer); break;
    case ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR: error_pretty_print_erb_multiple_blocks_in_tag_error((ERB_MULTIPLE_BLOCKS_IN_TAG_ERROR_T*) error, indent, relative_indent, buffer); break;
  }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/src/analyze_missing_end.c.erb

#include "include/analyze_helpers.h"
#include "include/errors.h"


void check_erb_node_for_missing_end(const AST_NODE_T* node) {
  switch (node->type) {
    case AST_ERB_IF_NODE: {
      const AST_ERB_IF_NODE_T* erb_if_node = (const AST_ERB_IF_NODE_T*) node;

      if (erb_if_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " if " "%" ">`",
          erb_if_node->tag_opening->location.start,
          erb_if_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_BLOCK_NODE: {
      const AST_ERB_BLOCK_NODE_T* erb_block_node = (const AST_ERB_BLOCK_NODE_T*) node;

      if (erb_block_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "ERB block",
          erb_block_node->tag_opening->location.start,
          erb_block_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_CASE_NODE: {
      const AST_ERB_CASE_NODE_T* erb_case_node = (const AST_ERB_CASE_NODE_T*) node;

      if (erb_case_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " case " "%" ">`",
          erb_case_node->tag_opening->location.start,
          erb_case_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_CASE_MATCH_NODE: {
      const AST_ERB_CASE_MATCH_NODE_T* erb_case_match_node = (const AST_ERB_CASE_MATCH_NODE_T*) node;

      if (erb_case_match_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " case " "%" ">`",
          erb_case_match_node->tag_opening->location.start,
          erb_case_match_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_WHILE_NODE: {
      const AST_ERB_WHILE_NODE_T* erb_while_node = (const AST_ERB_WHILE_NODE_T*) node;

      if (erb_while_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " while " "%" ">`",
          erb_while_node->tag_opening->location.start,
          erb_while_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_UNTIL_NODE: {
      const AST_ERB_UNTIL_NODE_T* erb_until_node = (const AST_ERB_UNTIL_NODE_T*) node;

      if (erb_until_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " until " "%" ">`",
          erb_until_node->tag_opening->location.start,
          erb_until_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_FOR_NODE: {
      const AST_ERB_FOR_NODE_T* erb_for_node = (const AST_ERB_FOR_NODE_T*) node;

      if (erb_for_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " for " "%" ">`",
          erb_for_node->tag_opening->location.start,
          erb_for_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_BEGIN_NODE: {
      const AST_ERB_BEGIN_NODE_T* erb_begin_node = (const AST_ERB_BEGIN_NODE_T*) node;

      if (erb_begin_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " begin " "%" ">`",
          erb_begin_node->tag_opening->location.start,
          erb_begin_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    case AST_ERB_UNLESS_NODE: {
      const AST_ERB_UNLESS_NODE_T* erb_unless_node = (const AST_ERB_UNLESS_NODE_T*) node;

      if (erb_unless_node->end_node == NULL) {
        append_missingerb_end_tag_error(
          "`<" "%" " unless " "%" ">`",
          erb_unless_node->tag_opening->location.start,
          erb_unless_node->tag_closing->location.end,
          node->errors
        );
      }

      break;
    }

    default: break;
  }
}

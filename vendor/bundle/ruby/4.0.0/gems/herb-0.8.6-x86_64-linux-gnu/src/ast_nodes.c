// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /home/runner/work/herb/herb/templates/src/ast_nodes.c.erb

#include <stdio.h>
#include <stdbool.h>

#include <prism.h>

#include "include/analyzed_ruby.h"
#include "include/ast_node.h"
#include "include/ast_nodes.h"
#include "include/errors.h"
#include "include/token.h"
#include "include/util.h"
#include "include/util/hb_array.h"


AST_DOCUMENT_NODE_T* ast_document_node_init(hb_array_T* children, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_DOCUMENT_NODE_T* document_node = malloc(sizeof(AST_DOCUMENT_NODE_T));

  ast_node_init(&document_node->base, AST_DOCUMENT_NODE, start_position, end_position, errors);

  if (children == NULL) {
    document_node->children = hb_array_init(8);
  } else {
    document_node->children = children;
  }

  return document_node;
}

AST_LITERAL_NODE_T* ast_literal_node_init(const char* content, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_LITERAL_NODE_T* literal_node = malloc(sizeof(AST_LITERAL_NODE_T));

  ast_node_init(&literal_node->base, AST_LITERAL_NODE, start_position, end_position, errors);

  literal_node->content = herb_strdup(content);

  return literal_node;
}

AST_HTML_OPEN_TAG_NODE_T* ast_html_open_tag_node_init(token_T* tag_opening, token_T* tag_name, token_T* tag_closing, hb_array_T* children, bool is_void, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_OPEN_TAG_NODE_T* html_open_tag_node = malloc(sizeof(AST_HTML_OPEN_TAG_NODE_T));

  ast_node_init(&html_open_tag_node->base, AST_HTML_OPEN_TAG_NODE, start_position, end_position, errors);

  html_open_tag_node->tag_opening = token_copy(tag_opening);
  html_open_tag_node->tag_name = token_copy(tag_name);
  html_open_tag_node->tag_closing = token_copy(tag_closing);
  if (children == NULL) {
    html_open_tag_node->children = hb_array_init(8);
  } else {
    html_open_tag_node->children = children;
  }
  html_open_tag_node->is_void = is_void;

  return html_open_tag_node;
}

AST_HTML_CLOSE_TAG_NODE_T* ast_html_close_tag_node_init(token_T* tag_opening, token_T* tag_name, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_CLOSE_TAG_NODE_T* html_close_tag_node = malloc(sizeof(AST_HTML_CLOSE_TAG_NODE_T));

  ast_node_init(&html_close_tag_node->base, AST_HTML_CLOSE_TAG_NODE, start_position, end_position, errors);

  html_close_tag_node->tag_opening = token_copy(tag_opening);
  html_close_tag_node->tag_name = token_copy(tag_name);
  if (children == NULL) {
    html_close_tag_node->children = hb_array_init(8);
  } else {
    html_close_tag_node->children = children;
  }
  html_close_tag_node->tag_closing = token_copy(tag_closing);

  return html_close_tag_node;
}

AST_HTML_ELEMENT_NODE_T* ast_html_element_node_init(struct AST_HTML_OPEN_TAG_NODE_STRUCT* open_tag, token_T* tag_name, hb_array_T* body, struct AST_HTML_CLOSE_TAG_NODE_STRUCT* close_tag, bool is_void, element_source_t source, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_ELEMENT_NODE_T* html_element_node = malloc(sizeof(AST_HTML_ELEMENT_NODE_T));

  ast_node_init(&html_element_node->base, AST_HTML_ELEMENT_NODE, start_position, end_position, errors);

  html_element_node->open_tag = open_tag;
  html_element_node->tag_name = token_copy(tag_name);
  if (body == NULL) {
    html_element_node->body = hb_array_init(8);
  } else {
    html_element_node->body = body;
  }
  html_element_node->close_tag = close_tag;
  html_element_node->is_void = is_void;
  html_element_node->source = source;

  return html_element_node;
}

AST_HTML_ATTRIBUTE_VALUE_NODE_T* ast_html_attribute_value_node_init(token_T* open_quote, hb_array_T* children, token_T* close_quote, bool quoted, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_ATTRIBUTE_VALUE_NODE_T* html_attribute_value_node = malloc(sizeof(AST_HTML_ATTRIBUTE_VALUE_NODE_T));

  ast_node_init(&html_attribute_value_node->base, AST_HTML_ATTRIBUTE_VALUE_NODE, start_position, end_position, errors);

  html_attribute_value_node->open_quote = token_copy(open_quote);
  if (children == NULL) {
    html_attribute_value_node->children = hb_array_init(8);
  } else {
    html_attribute_value_node->children = children;
  }
  html_attribute_value_node->close_quote = token_copy(close_quote);
  html_attribute_value_node->quoted = quoted;

  return html_attribute_value_node;
}

AST_HTML_ATTRIBUTE_NAME_NODE_T* ast_html_attribute_name_node_init(hb_array_T* children, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_ATTRIBUTE_NAME_NODE_T* html_attribute_name_node = malloc(sizeof(AST_HTML_ATTRIBUTE_NAME_NODE_T));

  ast_node_init(&html_attribute_name_node->base, AST_HTML_ATTRIBUTE_NAME_NODE, start_position, end_position, errors);

  if (children == NULL) {
    html_attribute_name_node->children = hb_array_init(8);
  } else {
    html_attribute_name_node->children = children;
  }

  return html_attribute_name_node;
}

AST_HTML_ATTRIBUTE_NODE_T* ast_html_attribute_node_init(struct AST_HTML_ATTRIBUTE_NAME_NODE_STRUCT* name, token_T* equals, struct AST_HTML_ATTRIBUTE_VALUE_NODE_STRUCT* value, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_ATTRIBUTE_NODE_T* html_attribute_node = malloc(sizeof(AST_HTML_ATTRIBUTE_NODE_T));

  ast_node_init(&html_attribute_node->base, AST_HTML_ATTRIBUTE_NODE, start_position, end_position, errors);

  html_attribute_node->name = name;
  html_attribute_node->equals = token_copy(equals);
  html_attribute_node->value = value;

  return html_attribute_node;
}

AST_HTML_TEXT_NODE_T* ast_html_text_node_init(const char* content, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_TEXT_NODE_T* html_text_node = malloc(sizeof(AST_HTML_TEXT_NODE_T));

  ast_node_init(&html_text_node->base, AST_HTML_TEXT_NODE, start_position, end_position, errors);

  html_text_node->content = herb_strdup(content);

  return html_text_node;
}

AST_HTML_COMMENT_NODE_T* ast_html_comment_node_init(token_T* comment_start, hb_array_T* children, token_T* comment_end, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_COMMENT_NODE_T* html_comment_node = malloc(sizeof(AST_HTML_COMMENT_NODE_T));

  ast_node_init(&html_comment_node->base, AST_HTML_COMMENT_NODE, start_position, end_position, errors);

  html_comment_node->comment_start = token_copy(comment_start);
  if (children == NULL) {
    html_comment_node->children = hb_array_init(8);
  } else {
    html_comment_node->children = children;
  }
  html_comment_node->comment_end = token_copy(comment_end);

  return html_comment_node;
}

AST_HTML_DOCTYPE_NODE_T* ast_html_doctype_node_init(token_T* tag_opening, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_HTML_DOCTYPE_NODE_T* html_doctype_node = malloc(sizeof(AST_HTML_DOCTYPE_NODE_T));

  ast_node_init(&html_doctype_node->base, AST_HTML_DOCTYPE_NODE, start_position, end_position, errors);

  html_doctype_node->tag_opening = token_copy(tag_opening);
  if (children == NULL) {
    html_doctype_node->children = hb_array_init(8);
  } else {
    html_doctype_node->children = children;
  }
  html_doctype_node->tag_closing = token_copy(tag_closing);

  return html_doctype_node;
}

AST_XML_DECLARATION_NODE_T* ast_xml_declaration_node_init(token_T* tag_opening, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_XML_DECLARATION_NODE_T* xml_declaration_node = malloc(sizeof(AST_XML_DECLARATION_NODE_T));

  ast_node_init(&xml_declaration_node->base, AST_XML_DECLARATION_NODE, start_position, end_position, errors);

  xml_declaration_node->tag_opening = token_copy(tag_opening);
  if (children == NULL) {
    xml_declaration_node->children = hb_array_init(8);
  } else {
    xml_declaration_node->children = children;
  }
  xml_declaration_node->tag_closing = token_copy(tag_closing);

  return xml_declaration_node;
}

AST_CDATA_NODE_T* ast_cdata_node_init(token_T* tag_opening, hb_array_T* children, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_CDATA_NODE_T* cdata_node = malloc(sizeof(AST_CDATA_NODE_T));

  ast_node_init(&cdata_node->base, AST_CDATA_NODE, start_position, end_position, errors);

  cdata_node->tag_opening = token_copy(tag_opening);
  if (children == NULL) {
    cdata_node->children = hb_array_init(8);
  } else {
    cdata_node->children = children;
  }
  cdata_node->tag_closing = token_copy(tag_closing);

  return cdata_node;
}

AST_WHITESPACE_NODE_T* ast_whitespace_node_init(token_T* value, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_WHITESPACE_NODE_T* whitespace_node = malloc(sizeof(AST_WHITESPACE_NODE_T));

  ast_node_init(&whitespace_node->base, AST_WHITESPACE_NODE, start_position, end_position, errors);

  whitespace_node->value = token_copy(value);

  return whitespace_node;
}

AST_ERB_CONTENT_NODE_T* ast_erb_content_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, analyzed_ruby_T* analyzed_ruby, bool parsed, bool valid, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_CONTENT_NODE_T* erb_content_node = malloc(sizeof(AST_ERB_CONTENT_NODE_T));

  ast_node_init(&erb_content_node->base, AST_ERB_CONTENT_NODE, start_position, end_position, errors);

  erb_content_node->tag_opening = token_copy(tag_opening);
  erb_content_node->content = token_copy(content);
  erb_content_node->tag_closing = token_copy(tag_closing);
  erb_content_node->analyzed_ruby = analyzed_ruby;
  erb_content_node->parsed = parsed;
  erb_content_node->valid = valid;

  return erb_content_node;
}

AST_ERB_END_NODE_T* ast_erb_end_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_END_NODE_T* erb_end_node = malloc(sizeof(AST_ERB_END_NODE_T));

  ast_node_init(&erb_end_node->base, AST_ERB_END_NODE, start_position, end_position, errors);

  erb_end_node->tag_opening = token_copy(tag_opening);
  erb_end_node->content = token_copy(content);
  erb_end_node->tag_closing = token_copy(tag_closing);

  return erb_end_node;
}

AST_ERB_ELSE_NODE_T* ast_erb_else_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_ELSE_NODE_T* erb_else_node = malloc(sizeof(AST_ERB_ELSE_NODE_T));

  ast_node_init(&erb_else_node->base, AST_ERB_ELSE_NODE, start_position, end_position, errors);

  erb_else_node->tag_opening = token_copy(tag_opening);
  erb_else_node->content = token_copy(content);
  erb_else_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_else_node->statements = hb_array_init(8);
  } else {
    erb_else_node->statements = statements;
  }

  return erb_else_node;
}

AST_ERB_IF_NODE_T* ast_erb_if_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_NODE_STRUCT* subsequent, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_IF_NODE_T* erb_if_node = malloc(sizeof(AST_ERB_IF_NODE_T));

  ast_node_init(&erb_if_node->base, AST_ERB_IF_NODE, start_position, end_position, errors);

  erb_if_node->tag_opening = token_copy(tag_opening);
  erb_if_node->content = token_copy(content);
  erb_if_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_if_node->statements = hb_array_init(8);
  } else {
    erb_if_node->statements = statements;
  }
  erb_if_node->subsequent = subsequent;
  erb_if_node->end_node = end_node;

  return erb_if_node;
}

AST_ERB_BLOCK_NODE_T* ast_erb_block_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* body, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_BLOCK_NODE_T* erb_block_node = malloc(sizeof(AST_ERB_BLOCK_NODE_T));

  ast_node_init(&erb_block_node->base, AST_ERB_BLOCK_NODE, start_position, end_position, errors);

  erb_block_node->tag_opening = token_copy(tag_opening);
  erb_block_node->content = token_copy(content);
  erb_block_node->tag_closing = token_copy(tag_closing);
  if (body == NULL) {
    erb_block_node->body = hb_array_init(8);
  } else {
    erb_block_node->body = body;
  }
  erb_block_node->end_node = end_node;

  return erb_block_node;
}

AST_ERB_WHEN_NODE_T* ast_erb_when_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_WHEN_NODE_T* erb_when_node = malloc(sizeof(AST_ERB_WHEN_NODE_T));

  ast_node_init(&erb_when_node->base, AST_ERB_WHEN_NODE, start_position, end_position, errors);

  erb_when_node->tag_opening = token_copy(tag_opening);
  erb_when_node->content = token_copy(content);
  erb_when_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_when_node->statements = hb_array_init(8);
  } else {
    erb_when_node->statements = statements;
  }

  return erb_when_node;
}

AST_ERB_CASE_NODE_T* ast_erb_case_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* children, hb_array_T* conditions, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_CASE_NODE_T* erb_case_node = malloc(sizeof(AST_ERB_CASE_NODE_T));

  ast_node_init(&erb_case_node->base, AST_ERB_CASE_NODE, start_position, end_position, errors);

  erb_case_node->tag_opening = token_copy(tag_opening);
  erb_case_node->content = token_copy(content);
  erb_case_node->tag_closing = token_copy(tag_closing);
  if (children == NULL) {
    erb_case_node->children = hb_array_init(8);
  } else {
    erb_case_node->children = children;
  }
  if (conditions == NULL) {
    erb_case_node->conditions = hb_array_init(8);
  } else {
    erb_case_node->conditions = conditions;
  }
  erb_case_node->else_clause = else_clause;
  erb_case_node->end_node = end_node;

  return erb_case_node;
}

AST_ERB_CASE_MATCH_NODE_T* ast_erb_case_match_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* children, hb_array_T* conditions, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_CASE_MATCH_NODE_T* erb_case_match_node = malloc(sizeof(AST_ERB_CASE_MATCH_NODE_T));

  ast_node_init(&erb_case_match_node->base, AST_ERB_CASE_MATCH_NODE, start_position, end_position, errors);

  erb_case_match_node->tag_opening = token_copy(tag_opening);
  erb_case_match_node->content = token_copy(content);
  erb_case_match_node->tag_closing = token_copy(tag_closing);
  if (children == NULL) {
    erb_case_match_node->children = hb_array_init(8);
  } else {
    erb_case_match_node->children = children;
  }
  if (conditions == NULL) {
    erb_case_match_node->conditions = hb_array_init(8);
  } else {
    erb_case_match_node->conditions = conditions;
  }
  erb_case_match_node->else_clause = else_clause;
  erb_case_match_node->end_node = end_node;

  return erb_case_match_node;
}

AST_ERB_WHILE_NODE_T* ast_erb_while_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_WHILE_NODE_T* erb_while_node = malloc(sizeof(AST_ERB_WHILE_NODE_T));

  ast_node_init(&erb_while_node->base, AST_ERB_WHILE_NODE, start_position, end_position, errors);

  erb_while_node->tag_opening = token_copy(tag_opening);
  erb_while_node->content = token_copy(content);
  erb_while_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_while_node->statements = hb_array_init(8);
  } else {
    erb_while_node->statements = statements;
  }
  erb_while_node->end_node = end_node;

  return erb_while_node;
}

AST_ERB_UNTIL_NODE_T* ast_erb_until_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_UNTIL_NODE_T* erb_until_node = malloc(sizeof(AST_ERB_UNTIL_NODE_T));

  ast_node_init(&erb_until_node->base, AST_ERB_UNTIL_NODE, start_position, end_position, errors);

  erb_until_node->tag_opening = token_copy(tag_opening);
  erb_until_node->content = token_copy(content);
  erb_until_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_until_node->statements = hb_array_init(8);
  } else {
    erb_until_node->statements = statements;
  }
  erb_until_node->end_node = end_node;

  return erb_until_node;
}

AST_ERB_FOR_NODE_T* ast_erb_for_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_FOR_NODE_T* erb_for_node = malloc(sizeof(AST_ERB_FOR_NODE_T));

  ast_node_init(&erb_for_node->base, AST_ERB_FOR_NODE, start_position, end_position, errors);

  erb_for_node->tag_opening = token_copy(tag_opening);
  erb_for_node->content = token_copy(content);
  erb_for_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_for_node->statements = hb_array_init(8);
  } else {
    erb_for_node->statements = statements;
  }
  erb_for_node->end_node = end_node;

  return erb_for_node;
}

AST_ERB_RESCUE_NODE_T* ast_erb_rescue_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_RESCUE_NODE_STRUCT* subsequent, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_RESCUE_NODE_T* erb_rescue_node = malloc(sizeof(AST_ERB_RESCUE_NODE_T));

  ast_node_init(&erb_rescue_node->base, AST_ERB_RESCUE_NODE, start_position, end_position, errors);

  erb_rescue_node->tag_opening = token_copy(tag_opening);
  erb_rescue_node->content = token_copy(content);
  erb_rescue_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_rescue_node->statements = hb_array_init(8);
  } else {
    erb_rescue_node->statements = statements;
  }
  erb_rescue_node->subsequent = subsequent;

  return erb_rescue_node;
}

AST_ERB_ENSURE_NODE_T* ast_erb_ensure_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_ENSURE_NODE_T* erb_ensure_node = malloc(sizeof(AST_ERB_ENSURE_NODE_T));

  ast_node_init(&erb_ensure_node->base, AST_ERB_ENSURE_NODE, start_position, end_position, errors);

  erb_ensure_node->tag_opening = token_copy(tag_opening);
  erb_ensure_node->content = token_copy(content);
  erb_ensure_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_ensure_node->statements = hb_array_init(8);
  } else {
    erb_ensure_node->statements = statements;
  }

  return erb_ensure_node;
}

AST_ERB_BEGIN_NODE_T* ast_erb_begin_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_RESCUE_NODE_STRUCT* rescue_clause, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_ENSURE_NODE_STRUCT* ensure_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_BEGIN_NODE_T* erb_begin_node = malloc(sizeof(AST_ERB_BEGIN_NODE_T));

  ast_node_init(&erb_begin_node->base, AST_ERB_BEGIN_NODE, start_position, end_position, errors);

  erb_begin_node->tag_opening = token_copy(tag_opening);
  erb_begin_node->content = token_copy(content);
  erb_begin_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_begin_node->statements = hb_array_init(8);
  } else {
    erb_begin_node->statements = statements;
  }
  erb_begin_node->rescue_clause = rescue_clause;
  erb_begin_node->else_clause = else_clause;
  erb_begin_node->ensure_clause = ensure_clause;
  erb_begin_node->end_node = end_node;

  return erb_begin_node;
}

AST_ERB_UNLESS_NODE_T* ast_erb_unless_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, struct AST_ERB_ELSE_NODE_STRUCT* else_clause, struct AST_ERB_END_NODE_STRUCT* end_node, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_UNLESS_NODE_T* erb_unless_node = malloc(sizeof(AST_ERB_UNLESS_NODE_T));

  ast_node_init(&erb_unless_node->base, AST_ERB_UNLESS_NODE, start_position, end_position, errors);

  erb_unless_node->tag_opening = token_copy(tag_opening);
  erb_unless_node->content = token_copy(content);
  erb_unless_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_unless_node->statements = hb_array_init(8);
  } else {
    erb_unless_node->statements = statements;
  }
  erb_unless_node->else_clause = else_clause;
  erb_unless_node->end_node = end_node;

  return erb_unless_node;
}

AST_ERB_YIELD_NODE_T* ast_erb_yield_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_YIELD_NODE_T* erb_yield_node = malloc(sizeof(AST_ERB_YIELD_NODE_T));

  ast_node_init(&erb_yield_node->base, AST_ERB_YIELD_NODE, start_position, end_position, errors);

  erb_yield_node->tag_opening = token_copy(tag_opening);
  erb_yield_node->content = token_copy(content);
  erb_yield_node->tag_closing = token_copy(tag_closing);

  return erb_yield_node;
}

AST_ERB_IN_NODE_T* ast_erb_in_node_init(token_T* tag_opening, token_T* content, token_T* tag_closing, hb_array_T* statements, position_T start_position, position_T end_position, hb_array_T* errors) {
  AST_ERB_IN_NODE_T* erb_in_node = malloc(sizeof(AST_ERB_IN_NODE_T));

  ast_node_init(&erb_in_node->base, AST_ERB_IN_NODE, start_position, end_position, errors);

  erb_in_node->tag_opening = token_copy(tag_opening);
  erb_in_node->content = token_copy(content);
  erb_in_node->tag_closing = token_copy(tag_closing);
  if (statements == NULL) {
    erb_in_node->statements = hb_array_init(8);
  } else {
    erb_in_node->statements = statements;
  }

  return erb_in_node;
}

hb_string_T ast_node_type_to_string(AST_NODE_T* node) {
  switch (node->type) {
    case AST_DOCUMENT_NODE: return hb_string("AST_DOCUMENT_NODE");
    case AST_LITERAL_NODE: return hb_string("AST_LITERAL_NODE");
    case AST_HTML_OPEN_TAG_NODE: return hb_string("AST_HTML_OPEN_TAG_NODE");
    case AST_HTML_CLOSE_TAG_NODE: return hb_string("AST_HTML_CLOSE_TAG_NODE");
    case AST_HTML_ELEMENT_NODE: return hb_string("AST_HTML_ELEMENT_NODE");
    case AST_HTML_ATTRIBUTE_VALUE_NODE: return hb_string("AST_HTML_ATTRIBUTE_VALUE_NODE");
    case AST_HTML_ATTRIBUTE_NAME_NODE: return hb_string("AST_HTML_ATTRIBUTE_NAME_NODE");
    case AST_HTML_ATTRIBUTE_NODE: return hb_string("AST_HTML_ATTRIBUTE_NODE");
    case AST_HTML_TEXT_NODE: return hb_string("AST_HTML_TEXT_NODE");
    case AST_HTML_COMMENT_NODE: return hb_string("AST_HTML_COMMENT_NODE");
    case AST_HTML_DOCTYPE_NODE: return hb_string("AST_HTML_DOCTYPE_NODE");
    case AST_XML_DECLARATION_NODE: return hb_string("AST_XML_DECLARATION_NODE");
    case AST_CDATA_NODE: return hb_string("AST_CDATA_NODE");
    case AST_WHITESPACE_NODE: return hb_string("AST_WHITESPACE_NODE");
    case AST_ERB_CONTENT_NODE: return hb_string("AST_ERB_CONTENT_NODE");
    case AST_ERB_END_NODE: return hb_string("AST_ERB_END_NODE");
    case AST_ERB_ELSE_NODE: return hb_string("AST_ERB_ELSE_NODE");
    case AST_ERB_IF_NODE: return hb_string("AST_ERB_IF_NODE");
    case AST_ERB_BLOCK_NODE: return hb_string("AST_ERB_BLOCK_NODE");
    case AST_ERB_WHEN_NODE: return hb_string("AST_ERB_WHEN_NODE");
    case AST_ERB_CASE_NODE: return hb_string("AST_ERB_CASE_NODE");
    case AST_ERB_CASE_MATCH_NODE: return hb_string("AST_ERB_CASE_MATCH_NODE");
    case AST_ERB_WHILE_NODE: return hb_string("AST_ERB_WHILE_NODE");
    case AST_ERB_UNTIL_NODE: return hb_string("AST_ERB_UNTIL_NODE");
    case AST_ERB_FOR_NODE: return hb_string("AST_ERB_FOR_NODE");
    case AST_ERB_RESCUE_NODE: return hb_string("AST_ERB_RESCUE_NODE");
    case AST_ERB_ENSURE_NODE: return hb_string("AST_ERB_ENSURE_NODE");
    case AST_ERB_BEGIN_NODE: return hb_string("AST_ERB_BEGIN_NODE");
    case AST_ERB_UNLESS_NODE: return hb_string("AST_ERB_UNLESS_NODE");
    case AST_ERB_YIELD_NODE: return hb_string("AST_ERB_YIELD_NODE");
    case AST_ERB_IN_NODE: return hb_string("AST_ERB_IN_NODE");
  }

  return hb_string("Unknown ast_node_type_T");
}

hb_string_T ast_node_human_type(AST_NODE_T* node) {
  switch (node->type) {
    case AST_DOCUMENT_NODE: return hb_string("DocumentNode");
    case AST_LITERAL_NODE: return hb_string("LiteralNode");
    case AST_HTML_OPEN_TAG_NODE: return hb_string("HTMLOpenTagNode");
    case AST_HTML_CLOSE_TAG_NODE: return hb_string("HTMLCloseTagNode");
    case AST_HTML_ELEMENT_NODE: return hb_string("HTMLElementNode");
    case AST_HTML_ATTRIBUTE_VALUE_NODE: return hb_string("HTMLAttributeValueNode");
    case AST_HTML_ATTRIBUTE_NAME_NODE: return hb_string("HTMLAttributeNameNode");
    case AST_HTML_ATTRIBUTE_NODE: return hb_string("HTMLAttributeNode");
    case AST_HTML_TEXT_NODE: return hb_string("HTMLTextNode");
    case AST_HTML_COMMENT_NODE: return hb_string("HTMLCommentNode");
    case AST_HTML_DOCTYPE_NODE: return hb_string("HTMLDoctypeNode");
    case AST_XML_DECLARATION_NODE: return hb_string("XMLDeclarationNode");
    case AST_CDATA_NODE: return hb_string("CDATANode");
    case AST_WHITESPACE_NODE: return hb_string("WhitespaceNode");
    case AST_ERB_CONTENT_NODE: return hb_string("ERBContentNode");
    case AST_ERB_END_NODE: return hb_string("ERBEndNode");
    case AST_ERB_ELSE_NODE: return hb_string("ERBElseNode");
    case AST_ERB_IF_NODE: return hb_string("ERBIfNode");
    case AST_ERB_BLOCK_NODE: return hb_string("ERBBlockNode");
    case AST_ERB_WHEN_NODE: return hb_string("ERBWhenNode");
    case AST_ERB_CASE_NODE: return hb_string("ERBCaseNode");
    case AST_ERB_CASE_MATCH_NODE: return hb_string("ERBCaseMatchNode");
    case AST_ERB_WHILE_NODE: return hb_string("ERBWhileNode");
    case AST_ERB_UNTIL_NODE: return hb_string("ERBUntilNode");
    case AST_ERB_FOR_NODE: return hb_string("ERBForNode");
    case AST_ERB_RESCUE_NODE: return hb_string("ERBRescueNode");
    case AST_ERB_ENSURE_NODE: return hb_string("ERBEnsureNode");
    case AST_ERB_BEGIN_NODE: return hb_string("ERBBeginNode");
    case AST_ERB_UNLESS_NODE: return hb_string("ERBUnlessNode");
    case AST_ERB_YIELD_NODE: return hb_string("ERBYieldNode");
    case AST_ERB_IN_NODE: return hb_string("ERBInNode");
  }

  return hb_string("Unknown ast_node_type_T");
}

void ast_free_base_node(AST_NODE_T* node) {
  if (node == NULL) { return; }

  if (node->errors) {
    for (size_t i = 0; i < node->errors->size; i++) {
      ERROR_T* child = hb_array_get(node->errors, i);
      if (child != NULL) { error_free(child); }
    }

    hb_array_free(&node->errors);
  }

  free(node);
}


static void ast_free_document_node(AST_DOCUMENT_NODE_T* document_node) {
  if (document_node->children != NULL) {
    for (size_t i = 0; i < document_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(document_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&document_node->children);
  }

  ast_free_base_node(&document_node->base);
}

static void ast_free_literal_node(AST_LITERAL_NODE_T* literal_node) {
  if (literal_node->content != NULL) { free((char*) literal_node->content); }

  ast_free_base_node(&literal_node->base);
}

static void ast_free_html_open_tag_node(AST_HTML_OPEN_TAG_NODE_T* html_open_tag_node) {
  if (html_open_tag_node->tag_opening != NULL) { token_free(html_open_tag_node->tag_opening); }
  if (html_open_tag_node->tag_name != NULL) { token_free(html_open_tag_node->tag_name); }
  if (html_open_tag_node->tag_closing != NULL) { token_free(html_open_tag_node->tag_closing); }
  if (html_open_tag_node->children != NULL) {
    for (size_t i = 0; i < html_open_tag_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(html_open_tag_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&html_open_tag_node->children);
  }

  ast_free_base_node(&html_open_tag_node->base);
}

static void ast_free_html_close_tag_node(AST_HTML_CLOSE_TAG_NODE_T* html_close_tag_node) {
  if (html_close_tag_node->tag_opening != NULL) { token_free(html_close_tag_node->tag_opening); }
  if (html_close_tag_node->tag_name != NULL) { token_free(html_close_tag_node->tag_name); }
  if (html_close_tag_node->children != NULL) {
    for (size_t i = 0; i < html_close_tag_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(html_close_tag_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&html_close_tag_node->children);
  }
  if (html_close_tag_node->tag_closing != NULL) { token_free(html_close_tag_node->tag_closing); }

  ast_free_base_node(&html_close_tag_node->base);
}

static void ast_free_html_element_node(AST_HTML_ELEMENT_NODE_T* html_element_node) {
  ast_node_free((AST_NODE_T*) html_element_node->open_tag);
  if (html_element_node->tag_name != NULL) { token_free(html_element_node->tag_name); }
  if (html_element_node->body != NULL) {
    for (size_t i = 0; i < html_element_node->body->size; i++) {
      AST_NODE_T* child = hb_array_get(html_element_node->body, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&html_element_node->body);
  }
  ast_node_free((AST_NODE_T*) html_element_node->close_tag);

  ast_free_base_node(&html_element_node->base);
}

static void ast_free_html_attribute_value_node(AST_HTML_ATTRIBUTE_VALUE_NODE_T* html_attribute_value_node) {
  if (html_attribute_value_node->open_quote != NULL) { token_free(html_attribute_value_node->open_quote); }
  if (html_attribute_value_node->children != NULL) {
    for (size_t i = 0; i < html_attribute_value_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(html_attribute_value_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&html_attribute_value_node->children);
  }
  if (html_attribute_value_node->close_quote != NULL) { token_free(html_attribute_value_node->close_quote); }

  ast_free_base_node(&html_attribute_value_node->base);
}

static void ast_free_html_attribute_name_node(AST_HTML_ATTRIBUTE_NAME_NODE_T* html_attribute_name_node) {
  if (html_attribute_name_node->children != NULL) {
    for (size_t i = 0; i < html_attribute_name_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(html_attribute_name_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&html_attribute_name_node->children);
  }

  ast_free_base_node(&html_attribute_name_node->base);
}

static void ast_free_html_attribute_node(AST_HTML_ATTRIBUTE_NODE_T* html_attribute_node) {
  ast_node_free((AST_NODE_T*) html_attribute_node->name);
  if (html_attribute_node->equals != NULL) { token_free(html_attribute_node->equals); }
  ast_node_free((AST_NODE_T*) html_attribute_node->value);

  ast_free_base_node(&html_attribute_node->base);
}

static void ast_free_html_text_node(AST_HTML_TEXT_NODE_T* html_text_node) {
  if (html_text_node->content != NULL) { free((char*) html_text_node->content); }

  ast_free_base_node(&html_text_node->base);
}

static void ast_free_html_comment_node(AST_HTML_COMMENT_NODE_T* html_comment_node) {
  if (html_comment_node->comment_start != NULL) { token_free(html_comment_node->comment_start); }
  if (html_comment_node->children != NULL) {
    for (size_t i = 0; i < html_comment_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(html_comment_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&html_comment_node->children);
  }
  if (html_comment_node->comment_end != NULL) { token_free(html_comment_node->comment_end); }

  ast_free_base_node(&html_comment_node->base);
}

static void ast_free_html_doctype_node(AST_HTML_DOCTYPE_NODE_T* html_doctype_node) {
  if (html_doctype_node->tag_opening != NULL) { token_free(html_doctype_node->tag_opening); }
  if (html_doctype_node->children != NULL) {
    for (size_t i = 0; i < html_doctype_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(html_doctype_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&html_doctype_node->children);
  }
  if (html_doctype_node->tag_closing != NULL) { token_free(html_doctype_node->tag_closing); }

  ast_free_base_node(&html_doctype_node->base);
}

static void ast_free_xml_declaration_node(AST_XML_DECLARATION_NODE_T* xml_declaration_node) {
  if (xml_declaration_node->tag_opening != NULL) { token_free(xml_declaration_node->tag_opening); }
  if (xml_declaration_node->children != NULL) {
    for (size_t i = 0; i < xml_declaration_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(xml_declaration_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&xml_declaration_node->children);
  }
  if (xml_declaration_node->tag_closing != NULL) { token_free(xml_declaration_node->tag_closing); }

  ast_free_base_node(&xml_declaration_node->base);
}

static void ast_free_cdata_node(AST_CDATA_NODE_T* cdata_node) {
  if (cdata_node->tag_opening != NULL) { token_free(cdata_node->tag_opening); }
  if (cdata_node->children != NULL) {
    for (size_t i = 0; i < cdata_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(cdata_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&cdata_node->children);
  }
  if (cdata_node->tag_closing != NULL) { token_free(cdata_node->tag_closing); }

  ast_free_base_node(&cdata_node->base);
}

static void ast_free_whitespace_node(AST_WHITESPACE_NODE_T* whitespace_node) {
  if (whitespace_node->value != NULL) { token_free(whitespace_node->value); }

  ast_free_base_node(&whitespace_node->base);
}

static void ast_free_erb_content_node(AST_ERB_CONTENT_NODE_T* erb_content_node) {
  if (erb_content_node->tag_opening != NULL) { token_free(erb_content_node->tag_opening); }
  if (erb_content_node->content != NULL) { token_free(erb_content_node->content); }
  if (erb_content_node->tag_closing != NULL) { token_free(erb_content_node->tag_closing); }
  if (erb_content_node->analyzed_ruby != NULL) {
    free_analyzed_ruby(erb_content_node->analyzed_ruby);
  }

  ast_free_base_node(&erb_content_node->base);
}

static void ast_free_erb_end_node(AST_ERB_END_NODE_T* erb_end_node) {
  if (erb_end_node->tag_opening != NULL) { token_free(erb_end_node->tag_opening); }
  if (erb_end_node->content != NULL) { token_free(erb_end_node->content); }
  if (erb_end_node->tag_closing != NULL) { token_free(erb_end_node->tag_closing); }

  ast_free_base_node(&erb_end_node->base);
}

static void ast_free_erb_else_node(AST_ERB_ELSE_NODE_T* erb_else_node) {
  if (erb_else_node->tag_opening != NULL) { token_free(erb_else_node->tag_opening); }
  if (erb_else_node->content != NULL) { token_free(erb_else_node->content); }
  if (erb_else_node->tag_closing != NULL) { token_free(erb_else_node->tag_closing); }
  if (erb_else_node->statements != NULL) {
    for (size_t i = 0; i < erb_else_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_else_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_else_node->statements);
  }

  ast_free_base_node(&erb_else_node->base);
}

static void ast_free_erb_if_node(AST_ERB_IF_NODE_T* erb_if_node) {
  if (erb_if_node->tag_opening != NULL) { token_free(erb_if_node->tag_opening); }
  if (erb_if_node->content != NULL) { token_free(erb_if_node->content); }
  if (erb_if_node->tag_closing != NULL) { token_free(erb_if_node->tag_closing); }
  if (erb_if_node->statements != NULL) {
    for (size_t i = 0; i < erb_if_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_if_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_if_node->statements);
  }
  ast_node_free((AST_NODE_T*) erb_if_node->subsequent);
  ast_node_free((AST_NODE_T*) erb_if_node->end_node);

  ast_free_base_node(&erb_if_node->base);
}

static void ast_free_erb_block_node(AST_ERB_BLOCK_NODE_T* erb_block_node) {
  if (erb_block_node->tag_opening != NULL) { token_free(erb_block_node->tag_opening); }
  if (erb_block_node->content != NULL) { token_free(erb_block_node->content); }
  if (erb_block_node->tag_closing != NULL) { token_free(erb_block_node->tag_closing); }
  if (erb_block_node->body != NULL) {
    for (size_t i = 0; i < erb_block_node->body->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_block_node->body, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_block_node->body);
  }
  ast_node_free((AST_NODE_T*) erb_block_node->end_node);

  ast_free_base_node(&erb_block_node->base);
}

static void ast_free_erb_when_node(AST_ERB_WHEN_NODE_T* erb_when_node) {
  if (erb_when_node->tag_opening != NULL) { token_free(erb_when_node->tag_opening); }
  if (erb_when_node->content != NULL) { token_free(erb_when_node->content); }
  if (erb_when_node->tag_closing != NULL) { token_free(erb_when_node->tag_closing); }
  if (erb_when_node->statements != NULL) {
    for (size_t i = 0; i < erb_when_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_when_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_when_node->statements);
  }

  ast_free_base_node(&erb_when_node->base);
}

static void ast_free_erb_case_node(AST_ERB_CASE_NODE_T* erb_case_node) {
  if (erb_case_node->tag_opening != NULL) { token_free(erb_case_node->tag_opening); }
  if (erb_case_node->content != NULL) { token_free(erb_case_node->content); }
  if (erb_case_node->tag_closing != NULL) { token_free(erb_case_node->tag_closing); }
  if (erb_case_node->children != NULL) {
    for (size_t i = 0; i < erb_case_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_case_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_case_node->children);
  }
  if (erb_case_node->conditions != NULL) {
    for (size_t i = 0; i < erb_case_node->conditions->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_case_node->conditions, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_case_node->conditions);
  }
  ast_node_free((AST_NODE_T*) erb_case_node->else_clause);
  ast_node_free((AST_NODE_T*) erb_case_node->end_node);

  ast_free_base_node(&erb_case_node->base);
}

static void ast_free_erb_case_match_node(AST_ERB_CASE_MATCH_NODE_T* erb_case_match_node) {
  if (erb_case_match_node->tag_opening != NULL) { token_free(erb_case_match_node->tag_opening); }
  if (erb_case_match_node->content != NULL) { token_free(erb_case_match_node->content); }
  if (erb_case_match_node->tag_closing != NULL) { token_free(erb_case_match_node->tag_closing); }
  if (erb_case_match_node->children != NULL) {
    for (size_t i = 0; i < erb_case_match_node->children->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_case_match_node->children, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_case_match_node->children);
  }
  if (erb_case_match_node->conditions != NULL) {
    for (size_t i = 0; i < erb_case_match_node->conditions->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_case_match_node->conditions, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_case_match_node->conditions);
  }
  ast_node_free((AST_NODE_T*) erb_case_match_node->else_clause);
  ast_node_free((AST_NODE_T*) erb_case_match_node->end_node);

  ast_free_base_node(&erb_case_match_node->base);
}

static void ast_free_erb_while_node(AST_ERB_WHILE_NODE_T* erb_while_node) {
  if (erb_while_node->tag_opening != NULL) { token_free(erb_while_node->tag_opening); }
  if (erb_while_node->content != NULL) { token_free(erb_while_node->content); }
  if (erb_while_node->tag_closing != NULL) { token_free(erb_while_node->tag_closing); }
  if (erb_while_node->statements != NULL) {
    for (size_t i = 0; i < erb_while_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_while_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_while_node->statements);
  }
  ast_node_free((AST_NODE_T*) erb_while_node->end_node);

  ast_free_base_node(&erb_while_node->base);
}

static void ast_free_erb_until_node(AST_ERB_UNTIL_NODE_T* erb_until_node) {
  if (erb_until_node->tag_opening != NULL) { token_free(erb_until_node->tag_opening); }
  if (erb_until_node->content != NULL) { token_free(erb_until_node->content); }
  if (erb_until_node->tag_closing != NULL) { token_free(erb_until_node->tag_closing); }
  if (erb_until_node->statements != NULL) {
    for (size_t i = 0; i < erb_until_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_until_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_until_node->statements);
  }
  ast_node_free((AST_NODE_T*) erb_until_node->end_node);

  ast_free_base_node(&erb_until_node->base);
}

static void ast_free_erb_for_node(AST_ERB_FOR_NODE_T* erb_for_node) {
  if (erb_for_node->tag_opening != NULL) { token_free(erb_for_node->tag_opening); }
  if (erb_for_node->content != NULL) { token_free(erb_for_node->content); }
  if (erb_for_node->tag_closing != NULL) { token_free(erb_for_node->tag_closing); }
  if (erb_for_node->statements != NULL) {
    for (size_t i = 0; i < erb_for_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_for_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_for_node->statements);
  }
  ast_node_free((AST_NODE_T*) erb_for_node->end_node);

  ast_free_base_node(&erb_for_node->base);
}

static void ast_free_erb_rescue_node(AST_ERB_RESCUE_NODE_T* erb_rescue_node) {
  if (erb_rescue_node->tag_opening != NULL) { token_free(erb_rescue_node->tag_opening); }
  if (erb_rescue_node->content != NULL) { token_free(erb_rescue_node->content); }
  if (erb_rescue_node->tag_closing != NULL) { token_free(erb_rescue_node->tag_closing); }
  if (erb_rescue_node->statements != NULL) {
    for (size_t i = 0; i < erb_rescue_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_rescue_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_rescue_node->statements);
  }
  ast_node_free((AST_NODE_T*) erb_rescue_node->subsequent);

  ast_free_base_node(&erb_rescue_node->base);
}

static void ast_free_erb_ensure_node(AST_ERB_ENSURE_NODE_T* erb_ensure_node) {
  if (erb_ensure_node->tag_opening != NULL) { token_free(erb_ensure_node->tag_opening); }
  if (erb_ensure_node->content != NULL) { token_free(erb_ensure_node->content); }
  if (erb_ensure_node->tag_closing != NULL) { token_free(erb_ensure_node->tag_closing); }
  if (erb_ensure_node->statements != NULL) {
    for (size_t i = 0; i < erb_ensure_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_ensure_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_ensure_node->statements);
  }

  ast_free_base_node(&erb_ensure_node->base);
}

static void ast_free_erb_begin_node(AST_ERB_BEGIN_NODE_T* erb_begin_node) {
  if (erb_begin_node->tag_opening != NULL) { token_free(erb_begin_node->tag_opening); }
  if (erb_begin_node->content != NULL) { token_free(erb_begin_node->content); }
  if (erb_begin_node->tag_closing != NULL) { token_free(erb_begin_node->tag_closing); }
  if (erb_begin_node->statements != NULL) {
    for (size_t i = 0; i < erb_begin_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_begin_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_begin_node->statements);
  }
  ast_node_free((AST_NODE_T*) erb_begin_node->rescue_clause);
  ast_node_free((AST_NODE_T*) erb_begin_node->else_clause);
  ast_node_free((AST_NODE_T*) erb_begin_node->ensure_clause);
  ast_node_free((AST_NODE_T*) erb_begin_node->end_node);

  ast_free_base_node(&erb_begin_node->base);
}

static void ast_free_erb_unless_node(AST_ERB_UNLESS_NODE_T* erb_unless_node) {
  if (erb_unless_node->tag_opening != NULL) { token_free(erb_unless_node->tag_opening); }
  if (erb_unless_node->content != NULL) { token_free(erb_unless_node->content); }
  if (erb_unless_node->tag_closing != NULL) { token_free(erb_unless_node->tag_closing); }
  if (erb_unless_node->statements != NULL) {
    for (size_t i = 0; i < erb_unless_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_unless_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_unless_node->statements);
  }
  ast_node_free((AST_NODE_T*) erb_unless_node->else_clause);
  ast_node_free((AST_NODE_T*) erb_unless_node->end_node);

  ast_free_base_node(&erb_unless_node->base);
}

static void ast_free_erb_yield_node(AST_ERB_YIELD_NODE_T* erb_yield_node) {
  if (erb_yield_node->tag_opening != NULL) { token_free(erb_yield_node->tag_opening); }
  if (erb_yield_node->content != NULL) { token_free(erb_yield_node->content); }
  if (erb_yield_node->tag_closing != NULL) { token_free(erb_yield_node->tag_closing); }

  ast_free_base_node(&erb_yield_node->base);
}

static void ast_free_erb_in_node(AST_ERB_IN_NODE_T* erb_in_node) {
  if (erb_in_node->tag_opening != NULL) { token_free(erb_in_node->tag_opening); }
  if (erb_in_node->content != NULL) { token_free(erb_in_node->content); }
  if (erb_in_node->tag_closing != NULL) { token_free(erb_in_node->tag_closing); }
  if (erb_in_node->statements != NULL) {
    for (size_t i = 0; i < erb_in_node->statements->size; i++) {
      AST_NODE_T* child = hb_array_get(erb_in_node->statements, i);
      if (child) { ast_node_free(child); }
    }

    hb_array_free(&erb_in_node->statements);
  }

  ast_free_base_node(&erb_in_node->base);
}

void ast_node_free(AST_NODE_T* node) {
  if (!node) { return; }

  switch (node->type) {
    case AST_DOCUMENT_NODE: ast_free_document_node((AST_DOCUMENT_NODE_T*) node); break;
    case AST_LITERAL_NODE: ast_free_literal_node((AST_LITERAL_NODE_T*) node); break;
    case AST_HTML_OPEN_TAG_NODE: ast_free_html_open_tag_node((AST_HTML_OPEN_TAG_NODE_T*) node); break;
    case AST_HTML_CLOSE_TAG_NODE: ast_free_html_close_tag_node((AST_HTML_CLOSE_TAG_NODE_T*) node); break;
    case AST_HTML_ELEMENT_NODE: ast_free_html_element_node((AST_HTML_ELEMENT_NODE_T*) node); break;
    case AST_HTML_ATTRIBUTE_VALUE_NODE: ast_free_html_attribute_value_node((AST_HTML_ATTRIBUTE_VALUE_NODE_T*) node); break;
    case AST_HTML_ATTRIBUTE_NAME_NODE: ast_free_html_attribute_name_node((AST_HTML_ATTRIBUTE_NAME_NODE_T*) node); break;
    case AST_HTML_ATTRIBUTE_NODE: ast_free_html_attribute_node((AST_HTML_ATTRIBUTE_NODE_T*) node); break;
    case AST_HTML_TEXT_NODE: ast_free_html_text_node((AST_HTML_TEXT_NODE_T*) node); break;
    case AST_HTML_COMMENT_NODE: ast_free_html_comment_node((AST_HTML_COMMENT_NODE_T*) node); break;
    case AST_HTML_DOCTYPE_NODE: ast_free_html_doctype_node((AST_HTML_DOCTYPE_NODE_T*) node); break;
    case AST_XML_DECLARATION_NODE: ast_free_xml_declaration_node((AST_XML_DECLARATION_NODE_T*) node); break;
    case AST_CDATA_NODE: ast_free_cdata_node((AST_CDATA_NODE_T*) node); break;
    case AST_WHITESPACE_NODE: ast_free_whitespace_node((AST_WHITESPACE_NODE_T*) node); break;
    case AST_ERB_CONTENT_NODE: ast_free_erb_content_node((AST_ERB_CONTENT_NODE_T*) node); break;
    case AST_ERB_END_NODE: ast_free_erb_end_node((AST_ERB_END_NODE_T*) node); break;
    case AST_ERB_ELSE_NODE: ast_free_erb_else_node((AST_ERB_ELSE_NODE_T*) node); break;
    case AST_ERB_IF_NODE: ast_free_erb_if_node((AST_ERB_IF_NODE_T*) node); break;
    case AST_ERB_BLOCK_NODE: ast_free_erb_block_node((AST_ERB_BLOCK_NODE_T*) node); break;
    case AST_ERB_WHEN_NODE: ast_free_erb_when_node((AST_ERB_WHEN_NODE_T*) node); break;
    case AST_ERB_CASE_NODE: ast_free_erb_case_node((AST_ERB_CASE_NODE_T*) node); break;
    case AST_ERB_CASE_MATCH_NODE: ast_free_erb_case_match_node((AST_ERB_CASE_MATCH_NODE_T*) node); break;
    case AST_ERB_WHILE_NODE: ast_free_erb_while_node((AST_ERB_WHILE_NODE_T*) node); break;
    case AST_ERB_UNTIL_NODE: ast_free_erb_until_node((AST_ERB_UNTIL_NODE_T*) node); break;
    case AST_ERB_FOR_NODE: ast_free_erb_for_node((AST_ERB_FOR_NODE_T*) node); break;
    case AST_ERB_RESCUE_NODE: ast_free_erb_rescue_node((AST_ERB_RESCUE_NODE_T*) node); break;
    case AST_ERB_ENSURE_NODE: ast_free_erb_ensure_node((AST_ERB_ENSURE_NODE_T*) node); break;
    case AST_ERB_BEGIN_NODE: ast_free_erb_begin_node((AST_ERB_BEGIN_NODE_T*) node); break;
    case AST_ERB_UNLESS_NODE: ast_free_erb_unless_node((AST_ERB_UNLESS_NODE_T*) node); break;
    case AST_ERB_YIELD_NODE: ast_free_erb_yield_node((AST_ERB_YIELD_NODE_T*) node); break;
    case AST_ERB_IN_NODE: ast_free_erb_in_node((AST_ERB_IN_NODE_T*) node); break;
  }
}

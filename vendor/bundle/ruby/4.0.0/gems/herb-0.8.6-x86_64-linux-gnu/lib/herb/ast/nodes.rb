# frozen_string_literal: true
# typed: true

# NOTE: This file is generated by the templates/template.rb script and should not be
# modified manually. See /home/runner/work/herb/herb/templates/lib/herb/ast/nodes.rb.erb

module Herb
  module AST
    class DocumentNode < Node
      include Colors

      attr_reader :children #: Array[Herb::AST::Node]

      #: (String, Location, Array[Herb::Errors::Error], Array[Herb::AST::Node]) -> void
      def initialize(type, location, errors, children)
        super(type, location, errors)
        @children = children
      end

      #: () -> serialized_document_node
      def to_hash
        super.merge({
          children: children,
        }) #: Herb::serialized_document_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_document_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("└── children: ")
        output += inspect_array(children, prefix: "    ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class LiteralNode < Node
      include Colors

      attr_reader :content #: String

      #: (String, Location, Array[Herb::Errors::Error], String) -> void
      def initialize(type, location, errors, content)
        super(type, location, errors)
        @content = content.force_encoding("utf-8")
      end

      #: () -> serialized_literal_node
      def to_hash
        super.merge({
          content: content,
        }) #: Herb::serialized_literal_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_literal_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        []
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("└── content: ") + green("#{content.inspect}\n")
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLOpenTagNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :tag_name #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :is_void #: bool

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], bool) -> void
      def initialize(type, location, errors, tag_opening, tag_name, tag_closing, children, is_void)
        super(type, location, errors)
        @tag_opening = tag_opening
        @tag_name = tag_name
        @tag_closing = tag_closing
        @children = children
        @is_void = is_void
      end

      #: () -> serialized_html_open_tag_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          tag_name: tag_name,
          tag_closing: tag_closing,
          children: children,
          is_void: is_void,
        }) #: Herb::serialized_html_open_tag_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_open_tag_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_name: ")
        output += tag_name ? tag_name.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── is_void: ")
        output += [true, false].include?(is_void) ? bold(magenta(is_void.to_s)) : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLCloseTagNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :tag_name #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :tag_closing #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::Token) -> void
      def initialize(type, location, errors, tag_opening, tag_name, children, tag_closing)
        super(type, location, errors)
        @tag_opening = tag_opening
        @tag_name = tag_name
        @children = children
        @tag_closing = tag_closing
      end

      #: () -> serialized_html_close_tag_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          tag_name: tag_name,
          children: children,
          tag_closing: tag_closing,
        }) #: Herb::serialized_html_close_tag_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_close_tag_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_name: ")
        output += tag_name ? tag_name.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLElementNode < Node
      include Colors

      attr_reader :open_tag #: Herb::AST::HTMLOpenTagNode
      attr_reader :tag_name #: Herb::Token
      attr_reader :body #: Array[Herb::AST::Node]
      attr_reader :close_tag #: Herb::AST::HTMLCloseTagNode
      attr_reader :is_void #: bool
      attr_reader :source #: String

      #: (String, Location, Array[Herb::Errors::Error], Herb::AST::HTMLOpenTagNode, Herb::Token, Array[Herb::AST::Node], Herb::AST::HTMLCloseTagNode, bool, String) -> void
      def initialize(type, location, errors, open_tag, tag_name, body, close_tag, is_void, source)
        super(type, location, errors)
        @open_tag = open_tag
        @tag_name = tag_name
        @body = body
        @close_tag = close_tag
        @is_void = is_void
        @source = source
      end

      #: () -> serialized_html_element_node
      def to_hash
        super.merge({
          open_tag: open_tag,
          tag_name: tag_name,
          body: body,
          close_tag: close_tag,
          is_void: is_void,
          source: source,
        }) #: Herb::serialized_html_element_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_element_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [open_tag, *body, close_tag]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── open_tag: ")
        if open_tag
          output += "\n"
          output += "│   └── "
          output += open_tag.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("├── tag_name: ")
        output += tag_name ? tag_name.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── body: ")
        output += inspect_array(body, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── close_tag: ")
        if close_tag
          output += "\n"
          output += "│   └── "
          output += close_tag.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("├── is_void: ")
        output += [true, false].include?(is_void) ? bold(magenta(is_void.to_s)) : magenta("∅")
        output += "\n"
        output += white("└── source: #{green(source.inspect)}\n")
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLAttributeValueNode < Node
      include Colors

      attr_reader :open_quote #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :close_quote #: Herb::Token
      attr_reader :quoted #: bool

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Array[Herb::AST::Node], Herb::Token, bool) -> void
      def initialize(type, location, errors, open_quote, children, close_quote, quoted)
        super(type, location, errors)
        @open_quote = open_quote
        @children = children
        @close_quote = close_quote
        @quoted = quoted
      end

      #: () -> serialized_html_attribute_value_node
      def to_hash
        super.merge({
          open_quote: open_quote,
          children: children,
          close_quote: close_quote,
          quoted: quoted,
        }) #: Herb::serialized_html_attribute_value_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_attribute_value_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── open_quote: ")
        output += open_quote ? open_quote.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── close_quote: ")
        output += close_quote ? close_quote.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── quoted: ")
        output += [true, false].include?(quoted) ? bold(magenta(quoted.to_s)) : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLAttributeNameNode < Node
      include Colors

      attr_reader :children #: Array[Herb::AST::Node]

      #: (String, Location, Array[Herb::Errors::Error], Array[Herb::AST::Node]) -> void
      def initialize(type, location, errors, children)
        super(type, location, errors)
        @children = children
      end

      #: () -> serialized_html_attribute_name_node
      def to_hash
        super.merge({
          children: children,
        }) #: Herb::serialized_html_attribute_name_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_attribute_name_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("└── children: ")
        output += inspect_array(children, prefix: "    ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLAttributeNode < Node
      include Colors

      attr_reader :name #: Herb::AST::HTMLAttributeNameNode
      attr_reader :equals #: Herb::Token
      attr_reader :value #: Herb::AST::HTMLAttributeValueNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::AST::HTMLAttributeNameNode, Herb::Token, Herb::AST::HTMLAttributeValueNode) -> void
      def initialize(type, location, errors, name, equals, value)
        super(type, location, errors)
        @name = name
        @equals = equals
        @value = value
      end

      #: () -> serialized_html_attribute_node
      def to_hash
        super.merge({
          name: name,
          equals: equals,
          value: value,
        }) #: Herb::serialized_html_attribute_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_attribute_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [name, value]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── name: ")
        if name
          output += "\n"
          output += "│   └── "
          output += name.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("├── equals: ")
        output += equals ? equals.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── value: ")
        if value
          output += "\n"
          output += "    └── "
          output += value.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLTextNode < Node
      include Colors

      attr_reader :content #: String

      #: (String, Location, Array[Herb::Errors::Error], String) -> void
      def initialize(type, location, errors, content)
        super(type, location, errors)
        @content = content.force_encoding("utf-8")
      end

      #: () -> serialized_html_text_node
      def to_hash
        super.merge({
          content: content,
        }) #: Herb::serialized_html_text_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_text_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        []
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("└── content: ") + green("#{content.inspect}\n")
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLCommentNode < Node
      include Colors

      attr_reader :comment_start #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :comment_end #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Array[Herb::AST::Node], Herb::Token) -> void
      def initialize(type, location, errors, comment_start, children, comment_end)
        super(type, location, errors)
        @comment_start = comment_start
        @children = children
        @comment_end = comment_end
      end

      #: () -> serialized_html_comment_node
      def to_hash
        super.merge({
          comment_start: comment_start,
          children: children,
          comment_end: comment_end,
        }) #: Herb::serialized_html_comment_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_comment_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── comment_start: ")
        output += comment_start ? comment_start.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── comment_end: ")
        output += comment_end ? comment_end.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class HTMLDoctypeNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :tag_closing #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Array[Herb::AST::Node], Herb::Token) -> void
      def initialize(type, location, errors, tag_opening, children, tag_closing)
        super(type, location, errors)
        @tag_opening = tag_opening
        @children = children
        @tag_closing = tag_closing
      end

      #: () -> serialized_html_doctype_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          children: children,
          tag_closing: tag_closing,
        }) #: Herb::serialized_html_doctype_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_html_doctype_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class XMLDeclarationNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :tag_closing #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Array[Herb::AST::Node], Herb::Token) -> void
      def initialize(type, location, errors, tag_opening, children, tag_closing)
        super(type, location, errors)
        @tag_opening = tag_opening
        @children = children
        @tag_closing = tag_closing
      end

      #: () -> serialized_xml_declaration_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          children: children,
          tag_closing: tag_closing,
        }) #: Herb::serialized_xml_declaration_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_xml_declaration_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class CDATANode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :tag_closing #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Array[Herb::AST::Node], Herb::Token) -> void
      def initialize(type, location, errors, tag_opening, children, tag_closing)
        super(type, location, errors)
        @tag_opening = tag_opening
        @children = children
        @tag_closing = tag_closing
      end

      #: () -> serialized_cdata_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          children: children,
          tag_closing: tag_closing,
        }) #: Herb::serialized_cdata_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_cdata_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class WhitespaceNode < Node
      include Colors

      attr_reader :value #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token) -> void
      def initialize(type, location, errors, value)
        super(type, location, errors)
        @value = value
      end

      #: () -> serialized_whitespace_node
      def to_hash
        super.merge({
          value: value,
        }) #: Herb::serialized_whitespace_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_whitespace_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        []
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("└── value: ")
        output += value ? value.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBContentNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :analyzed_ruby #: nil
      attr_reader :parsed #: bool
      attr_reader :valid #: bool

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, nil, bool, bool) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, analyzed_ruby, parsed, valid)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @analyzed_ruby = analyzed_ruby
        @parsed = parsed
        @valid = valid
      end

      #: () -> serialized_erb_content_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          analyzed_ruby: analyzed_ruby,
          parsed: parsed,
          valid: valid,
        }) #: Herb::serialized_erb_content_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_content_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        []
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        # no-op for analyzed_ruby
        output += white("├── parsed: ")
        output += [true, false].include?(parsed) ? bold(magenta(parsed.to_s)) : magenta("∅")
        output += "\n"
        output += white("└── valid: ")
        output += [true, false].include?(valid) ? bold(magenta(valid.to_s)) : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBEndNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
      end

      #: () -> serialized_erb_end_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
        }) #: Herb::serialized_erb_end_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_end_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        []
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBElseNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node]) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
      end

      #: () -> serialized_erb_else_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
        }) #: Herb::serialized_erb_else_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_else_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── statements: ")
        output += inspect_array(statements, prefix: "    ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBIfNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]
      attr_reader :subsequent #: Herb::AST::Node
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::Node, Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements, subsequent, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
        @subsequent = subsequent
        @end_node = end_node
      end

      #: () -> serialized_erb_if_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
          subsequent: subsequent,
          end_node: end_node,
        }) #: Herb::serialized_erb_if_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_if_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements, subsequent, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── statements: ")
        output += inspect_array(statements, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── subsequent: ")
        if subsequent
          output += "\n"
          output += "│   └── "
          output += subsequent.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBBlockNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :body #: Array[Herb::AST::Node]
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, body, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @body = body
        @end_node = end_node
      end

      #: () -> serialized_erb_block_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          body: body,
          end_node: end_node,
        }) #: Herb::serialized_erb_block_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_block_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*body, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── body: ")
        output += inspect_array(body, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBWhenNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node]) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
      end

      #: () -> serialized_erb_when_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
        }) #: Herb::serialized_erb_when_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_when_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── statements: ")
        output += inspect_array(statements, prefix: "    ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBCaseNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :conditions #: Array[Herb::AST::ERBWhenNode]
      attr_reader :else_clause #: Herb::AST::ERBElseNode
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Array[Herb::AST::ERBWhenNode], Herb::AST::ERBElseNode, Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, children, conditions, else_clause, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @children = children
        @conditions = conditions
        @else_clause = else_clause
        @end_node = end_node
      end

      #: () -> serialized_erb_case_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          children: children,
          conditions: conditions,
          else_clause: else_clause,
          end_node: end_node,
        }) #: Herb::serialized_erb_case_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_case_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children, *conditions, else_clause, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── conditions: ")
        output += inspect_array(conditions, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── else_clause: ")
        if else_clause
          output += "\n"
          output += "│   └── "
          output += else_clause.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBCaseMatchNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :children #: Array[Herb::AST::Node]
      attr_reader :conditions #: Array[Herb::AST::ERBInNode]
      attr_reader :else_clause #: Herb::AST::ERBElseNode
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Array[Herb::AST::ERBInNode], Herb::AST::ERBElseNode, Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, children, conditions, else_clause, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @children = children
        @conditions = conditions
        @else_clause = else_clause
        @end_node = end_node
      end

      #: () -> serialized_erb_case_match_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          children: children,
          conditions: conditions,
          else_clause: else_clause,
          end_node: end_node,
        }) #: Herb::serialized_erb_case_match_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_case_match_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*children, *conditions, else_clause, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── children: ")
        output += inspect_array(children, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── conditions: ")
        output += inspect_array(conditions, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── else_clause: ")
        if else_clause
          output += "\n"
          output += "│   └── "
          output += else_clause.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBWhileNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
        @end_node = end_node
      end

      #: () -> serialized_erb_while_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
          end_node: end_node,
        }) #: Herb::serialized_erb_while_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_while_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── statements: ")
        output += inspect_array(statements, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBUntilNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
        @end_node = end_node
      end

      #: () -> serialized_erb_until_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
          end_node: end_node,
        }) #: Herb::serialized_erb_until_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_until_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── statements: ")
        output += inspect_array(statements, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBForNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
        @end_node = end_node
      end

      #: () -> serialized_erb_for_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
          end_node: end_node,
        }) #: Herb::serialized_erb_for_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_for_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── statements: ")
        output += inspect_array(statements, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBRescueNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]
      attr_reader :subsequent #: Herb::AST::ERBRescueNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::ERBRescueNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements, subsequent)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
        @subsequent = subsequent
      end

      #: () -> serialized_erb_rescue_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
          subsequent: subsequent,
        }) #: Herb::serialized_erb_rescue_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_rescue_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements, subsequent]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── statements: ")
        output += inspect_array(statements, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("└── subsequent: ")
        if subsequent
          output += "\n"
          output += "    └── "
          output += subsequent.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBEnsureNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node]) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
      end

      #: () -> serialized_erb_ensure_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
        }) #: Herb::serialized_erb_ensure_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_ensure_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── statements: ")
        output += inspect_array(statements, prefix: "    ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBBeginNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]
      attr_reader :rescue_clause #: Herb::AST::ERBRescueNode
      attr_reader :else_clause #: Herb::AST::ERBElseNode
      attr_reader :ensure_clause #: Herb::AST::ERBEnsureNode
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::ERBRescueNode, Herb::AST::ERBElseNode, Herb::AST::ERBEnsureNode, Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements, rescue_clause, else_clause, ensure_clause, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
        @rescue_clause = rescue_clause
        @else_clause = else_clause
        @ensure_clause = ensure_clause
        @end_node = end_node
      end

      #: () -> serialized_erb_begin_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
          rescue_clause: rescue_clause,
          else_clause: else_clause,
          ensure_clause: ensure_clause,
          end_node: end_node,
        }) #: Herb::serialized_erb_begin_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_begin_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements, rescue_clause, else_clause, ensure_clause, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── statements: ")
        output += inspect_array(statements, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── rescue_clause: ")
        if rescue_clause
          output += "\n"
          output += "│   └── "
          output += rescue_clause.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("├── else_clause: ")
        if else_clause
          output += "\n"
          output += "│   └── "
          output += else_clause.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("├── ensure_clause: ")
        if ensure_clause
          output += "\n"
          output += "│   └── "
          output += ensure_clause.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBUnlessNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]
      attr_reader :else_clause #: Herb::AST::ERBElseNode
      attr_reader :end_node #: Herb::AST::ERBEndNode

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node], Herb::AST::ERBElseNode, Herb::AST::ERBEndNode) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements, else_clause, end_node)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
        @else_clause = else_clause
        @end_node = end_node
      end

      #: () -> serialized_erb_unless_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
          else_clause: else_clause,
          end_node: end_node,
        }) #: Herb::serialized_erb_unless_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_unless_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements, else_clause, end_node]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── statements: ")
        output += inspect_array(statements, prefix: "│   ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += white("├── else_clause: ")
        if else_clause
          output += "\n"
          output += "│   └── "
          output += else_clause.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "│   ").delete_prefix("│   ")
        else
          output += magenta("∅\n")
        end
        output += white("└── end_node: ")
        if end_node
          output += "\n"
          output += "    └── "
          output += end_node.tree_inspect(indent: indent, depth: depth + 1, depth_limit: depth_limit).gsub(/^/, "    " * (indent + 1)).lstrip.gsub(/^/, "    ").delete_prefix("    ")
        else
          output += magenta("∅\n")
        end
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBYieldNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
      end

      #: () -> serialized_erb_yield_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
        }) #: Herb::serialized_erb_yield_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_yield_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        []
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

    class ERBInNode < Node
      include Colors

      attr_reader :tag_opening #: Herb::Token
      attr_reader :content #: Herb::Token
      attr_reader :tag_closing #: Herb::Token
      attr_reader :statements #: Array[Herb::AST::Node]

      #: (String, Location, Array[Herb::Errors::Error], Herb::Token, Herb::Token, Herb::Token, Array[Herb::AST::Node]) -> void
      def initialize(type, location, errors, tag_opening, content, tag_closing, statements)
        super(type, location, errors)
        @tag_opening = tag_opening
        @content = content
        @tag_closing = tag_closing
        @statements = statements
      end

      #: () -> serialized_erb_in_node
      def to_hash
        super.merge({
          tag_opening: tag_opening,
          content: content,
          tag_closing: tag_closing,
          statements: statements,
        }) #: Herb::serialized_erb_in_node
      end

      #: (Visitor) -> void
      def accept(visitor)
        visitor.visit_erb_in_node(self)
      end

      #: () -> Array[Herb::AST::Node?]
      def child_nodes
        [*statements]
      end

      #: () -> Array[Herb::AST::Node]
      def compact_child_nodes
        child_nodes.compact
      end

      #: () -> String
      def inspect
        tree_inspect.rstrip.gsub(/\s+$/, "")
      end

      #: (?indent: Integer, ?depth: Integer, ?depth_limit: Integer) -> String
      def tree_inspect(indent: 0, depth: 0, depth_limit: 10)
        output = +""

        output += white("@ #{bold(yellow(node_name.to_s))} #{dimmed("(location: #{location.tree_inspect})")}")
        output += "\n"

        if depth >= depth_limit
          output += dimmed("└── [depth limit reached ...]\n\n")

          return output.gsub(/^/, "    " * indent)
        end

        output += inspect_errors(prefix: "│   ")

        output += white("├── tag_opening: ")
        output += tag_opening ? tag_opening.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── content: ")
        output += content ? content.tree_inspect : magenta("∅")
        output += "\n"
        output += white("├── tag_closing: ")
        output += tag_closing ? tag_closing.tree_inspect : magenta("∅")
        output += "\n"
        output += white("└── statements: ")
        output += inspect_array(statements, prefix: "    ", indent: indent, depth: depth + 1, depth_limit: depth_limit)
        output += "\n"

        output.gsub(/^/, "    " * indent)
      end
    end

  end
end

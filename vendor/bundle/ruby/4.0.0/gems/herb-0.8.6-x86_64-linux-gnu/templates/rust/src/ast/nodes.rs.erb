use crate::bindings::*;
use crate::convert::token_from_c;
use crate::errors::*;
use crate::nodes::*;
use crate::{Location, Position};
use std::ffi::CStr;
use std::os::raw::{c_char, c_void};

unsafe fn convert_location(c_location: location_T) -> Location {
  Location::new(
    Position::new(c_location.start.line, c_location.start.column),
    Position::new(c_location.end.line, c_location.end.column),
  )
}

<%- errors.each do |error| -%>
<%- snake_name = error.name.gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z])/, '\1_\2').downcase -%>
unsafe fn convert_<%= snake_name %>(error_ptr: *const <%= error.c_type %>) -> <%= error.name %> {
  let error_ref = &*error_ptr;
  let message = if error_ref.base.message.is_null() {
    String::new()
  } else {
    CStr::from_ptr(error_ref.base.message).to_string_lossy().into_owned()
  };
  let location = convert_location(error_ref.base.location);

  <%= error.name %>::new(
    message,
    location,
    <%- error.fields.each do |field| -%>
    <%- case field -%>
    <%- when Herb::Template::StringField -%>
    get_string_field(error_ref.<%= field.name %>),
    <%- when Herb::Template::TokenField -%>
    convert_token_field(error_ref.<%= field.name %>),
    <%- when Herb::Template::TokenTypeField -%>
    if error_ref.<%= field.name %> == u32::MAX {
      None
    } else {
      Some(CStr::from_ptr(crate::ffi::token_type_to_string(error_ref.<%= field.name %>)).to_string_lossy().into_owned())
    },
    <%- end -%>
    <%- end -%>
  )
}

<%- end -%>

unsafe fn convert_errors(errors_array: *mut hb_array_T) -> Vec<AnyError> {
  if errors_array.is_null() {
    return Vec::new();
  }

  let count = (*errors_array).size;
  let mut errors = Vec::with_capacity(count);

  for index in 0..count {
    let error_base_ptr = hb_array_get(errors_array, index) as *const ERROR_T;
    if error_base_ptr.is_null() {
      continue;
    }

    let error_base = &*error_base_ptr;

    let error = match error_base.type_ {
        <%- errors.each do |error| -%>
        <%- snake_name = error.name.gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z])/, '\1_\2').downcase -%>
        <%= error.type %> => {
          let error_ptr = error_base_ptr as *const <%= error.c_type %>;
          AnyError::<%= error.name %>(convert_<%= snake_name %>(error_ptr))
        }
        <%- end -%>
        _ => continue,
    };

    errors.push(error);
  }

  errors
}

unsafe fn get_string_field(string_ptr: *const c_char) -> String {
  if string_ptr.is_null() {
    String::new()
  } else {
    CStr::from_ptr(string_ptr).to_string_lossy().into_owned()
  }
}

unsafe fn convert_element_source(source: u32) -> String {
  let hb_string = crate::ffi::element_source_to_string(source);
  if hb_string.data.is_null() {
    String::new()
  } else {
    let slice = std::slice::from_raw_parts(hb_string.data as *const u8, hb_string.length as usize);
    String::from_utf8_lossy(slice).into_owned()
  }
}

unsafe fn convert_token_field(token_ptr: *mut token_T) -> Option<crate::Token> {
  if token_ptr.is_null() {
    None
  } else {
    Some(token_from_c(token_ptr))
  }
}

unsafe fn convert_children(children_array: *mut hb_array_T) -> Vec<AnyNode> {
  if children_array.is_null() {
    return Vec::new();
  }

  let count = (*children_array).size;
  let mut children = Vec::with_capacity(count);

  for index in 0..count {
    let child_ptr = hb_array_get(children_array, index);
    if !child_ptr.is_null() {
      if let Some(node) = convert_node(child_ptr as *const c_void) {
        children.push(node);
      }
    }
  }

  children
}

unsafe fn convert_node_field(node_ptr: *mut c_void) -> Option<Box<AnyNode>> {
  if node_ptr.is_null() {
    None
  } else {
    convert_node(node_ptr).map(Box::new)
  }
}

macro_rules! convert_specific_node_field {
  ($node_ptr:expr, $expected_type:expr, $convert_fn:ident, $node_type:ty) => {
    if $node_ptr.is_null() {
      None
    } else {
      let ast_base_ptr = $node_ptr as *const AST_NODE_T;
      let ast_base_ref = &*ast_base_ptr;
      let node_type = ast_base_ref.type_;

      if node_type != $expected_type {
        eprintln!("Warning: Expected node type {} but got {}", $expected_type, node_type);
        None
      } else {
        $convert_fn($node_ptr as *const c_void).map(Box::new)
      }
    }
  };
}

unsafe fn convert_node(node_ptr: *const c_void) -> Option<AnyNode> {
  if node_ptr.is_null() {
    return None;
  }

  let ast_base_ptr = node_ptr as *const AST_NODE_T;
  let ast_base_ref = &*ast_base_ptr;
  let node_type = ast_base_ref.type_;

  match node_type {
    <%- nodes.each do |node| -%>
    <%= node.type %> => convert_<%= node.human %>(node_ptr).map(AnyNode::<%= node.name %>),
    <%- end -%>
    _ => {
      eprintln!("Warning: Unknown node type {}", node_type);
      None
    }
  }
}

  <%- nodes.each do |node| -%>
  <%- if node.name == "DocumentNode" -%>
  /// Converts a C document node pointer to a Rust DocumentNode.
  ///
  /// # Safety
  ///
  /// The caller must ensure that `node_ptr` is a valid pointer to a C document node
  /// structure with properly initialized fields.
  <%- end -%>
  <%= node.name == "DocumentNode" ? "pub " : "" %>unsafe fn convert_<%= node.human %>(node_ptr: *const c_void) -> Option<<%= node.name %>> {
    if node_ptr.is_null() {
      return None;
    }

    let c_node_ptr = node_ptr as *const <%= node.c_type %>;
    let node_base_ref = &(*c_node_ptr).base;

    Some(<%= node.name %> {
      node_type: "<%= node.name %>".to_string(),
      location: convert_location(node_base_ref.location),
      errors: convert_errors(node_base_ref.errors),
      <%- node.fields.each do |field| -%>
      <%- case field -%>
      <%- when Herb::Template::StringField -%>
      <%= field.name %>: get_string_field((*c_node_ptr).<%= field.name %>),
      <%- when Herb::Template::ElementSourceField -%>
      <%= field.name %>: convert_element_source((*c_node_ptr).<%= field.name %>),
      <%- when Herb::Template::TokenField -%>
      <%= field.name %>: convert_token_field((*c_node_ptr).<%= field.name %>),
      <%- when Herb::Template::BooleanField -%>
      <%= field.name %>: (*c_node_ptr).<%= field.name %>,
      <%- when Herb::Template::ArrayField -%>
      <%= field.name %>: convert_children((*c_node_ptr).<%= field.name %>),
      <%- when Herb::Template::NodeField -%>
      <%- if field.specific_kind && field.specific_kind != "Node" -%>
      <%- specific_node = nodes.find { |n| n.name == field.specific_kind } -%>
      <%= field.name %>: convert_specific_node_field!((*c_node_ptr).<%= field.name %>, <%= specific_node.type %>, convert_<%= specific_node.human %>, <%= field.specific_kind %>),
      <%- else -%>
      <%= field.name %>: convert_node_field((*c_node_ptr).<%= field.name %> as *mut c_void),
      <%- end -%>
      <%- end -%>
      <%- end -%>
    })
  }

<%- end -%>
